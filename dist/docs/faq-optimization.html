<div id="directory" class="section">
<h1>FAQ: RequireJS Optimizations</h1>
<ul class="index mono">
<li class="hbox"><a href="#usage">如何使用优化工具？</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1</span></li>
<li class="hbox"><a href="#wrap">如何创建不依赖RequireJS的类库？</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span></li>
<li class="hbox"><a href="#namespace">如何管理命名空间，在别人的页面里不会产生冲突？</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span></li>
<li class="hbox"><a href="#priority">如何并行下载所有脚本依赖？</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4</span></li>
</ul>
</div>

<div class="section">
<h2><a name="usage">如何使用优化工具？</a><span class="sectionMark">&sect; 1</span></h2>

<p>基本的设置，请参考 <a href="optimization.html">一般优化页面</a> 。同时也可以参考 <a href="jquery.html">jQuery 文档页面</a>，更好地设置你的项目，即使你没有使用jQuery。</p>
</div>

<div class="section">
<h2><a name="wrap">如何创建不依赖RequireJS的类库？</a><span class="sectionMark">&sect; 2</span></h2>

<p>If you are building a library for use on web pages that may not use RequireJS or an AMD loader, you can use the optimizer to combine
all your modules into one file, then wrap them in a function and use an AMD API shim. This allows you to ship code that does not ship with all
of RequireJS, and allows you to export any kind of API that works on a plain web page without an AMD loader.</p>

<p><a href="https://github.com/jrburke/almond">almond</a> is an AMD API shim that is very small, so it can be used in place of require.js
when all of your modules are built into one file using the RequireJS optimizer. The
<a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js#L244">wrap</a> build config option will put a function
wrapper around the code, or you can provide your own wrapper if you need to do extra logic.</p>

<p>See the almond project for details on how to build with the API shim and with wrap.</p>

<p>If you need to dynamically load code after a build, then using almond+wrap will not be sufficient as almond cannot dynamically
load code. Instead, you may want to namespace your use of require/define. See next section.</p>
</div>

<div class="section">
<h2><a name="namespace">How can I namespace my code to play well in other people's pages?</a><span class="sectionMark">&sect; 3</span></h2>

<p>If you want to provide your code to web sites that may not use an AMD loader, and you need to dynamically load code,
doing a simple <a href="#wrap">one file build with a wrapper</a> is not enough. You also may want isolate your loading needs from
the page's AMD loader.</p>

<p>There is a <a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js#L159">namespace</a> build option that
does the following:</p>

<ul>
    <li>Renames requirejs, require and define uses to have "namespace." in front of them.</li>
    <li>If the file does an existence check for define, in the following form <code>typeof define === 'function' && define.amd</code>,
    then it will prefix the define references with "namespace.".</li>
    <li>If require.js is included in the built file, it will make sure it exposes the "namespace." versions of the API.</li>
</ul>

<p>Do not code your source with namespace.require()/namespace.define() calls, but rather use require()/define() as you
normally would, then use the optimizer to do the renaming.</p>

</div>

<div class="section">
<h2><a name="priority">如何并行下载所有脚本依赖？</a><span class="sectionMark">&sect; 4</span></h2>

<p>使用 <a href="">require()</a> 和 <a href="api.html#define">define()</a> 函数来定义脚本模块和依赖是一种高效的表达代码相关性的语法。不过对于在浏览器里部署代码来说，它可能不是一个性能最好的方案。当一个脚本文件需要知道它嵌套的依赖的时候，它必须得被下载，然后，require()或者define()又会被调用来下载别的脚本文件。</p>

<p><a href="optimization.html">优化工具</a>可以快速的<a href="optimization.html#onejs">将你所有的脚本文件build到一个文件</a>。这样，在你的页面中只要下载一个脚本文件就可以了。</p>

<p>不过，如果你的web应用有很多页面的时候，就应该考虑将你的脚本优化成一组两到三层的结构：</p>

<ul>
<li>第一层是公共工具类代码，例如jQuery, Dojo, Prototype or MooTools (toolkit.js). 可以考虑将这层并入appcommon.js层。</li>
<li>第二层是公共web应用代码。(appcommon.js)</li>
<li>第三层是页面相关的代码。(page.js)</li>
</ul>

<p>理论上你可以在完成开发以后分层，然后优化，并行下载文件。这不会造成很大的代码修改。</p>

<p>使用RequireJS可以实现上述分层:</p>

<ul>
<li><a href="optimization.html#wholeproject">优化你的项目</a>创建三层脚本代码层。</li>
<li>使用<a href="api.html#config"><strong>优先</strong> 配置值</a>，在HTML文件里，向最高层的require()调用传递层的下载列表。</li>
</ul>

<p>在配置的优先队列里定义的脚本模块或文件将会在别的脚本依赖之前被并行下载。 <b>注意：</b> 被加载器插件加载的资源（例如'text!template.html'）<b>不能</b>被加入优先队列，优先队列只能包含普通的JavaScript资源。</p>

<p>这个示例是建立在 <a href="download.html#samplejquery">jQuery示例项目</a>之上来演示如何实现：</p>

<p>Assume the project has the following structure:</p>

<ul>
<li>app.build.js (优化工具使用的配置文件)</li>
<li>webapp
<ul>
<li>page1.html</li>
<li>page2.html</li>
<li>scripts
<ul>
<li>require.js (加载器)</li>
<li>appcommon.js (应用在两个页面上, "appcommon")</li>
<li>jquery.js (应用在两个页面上, "appcommon")</li>
<li>page1.js (为页面1罗列依赖关系)</li>
<li>page2.js (为页面2罗列依赖关系)</li>
<li>object.js (应用在两个页面上, "appcommon")</li>
<li>event.js (应用在两个页面上, "appcommon")</li>
<li>widget.js (应用在两个页面上, "appcommon")</li>
<li>Dialog.js (应用在两个页面上, "appcommon")</li>
<li>Slider.js (只在页面2上应用)</li>
<li>Tabs.js (只在页面1上应用)</li>
</ul></li>
</ul></li>
<li>webapp-build
<ul>
<li>这个目录会包含被优化的文件</li>
</ul></li>
</ul>

<p>page1.html 会是这样:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Page 1&lt;/title&gt;
        &lt;script src="scripts/require.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            require.config({
                priority: ["appcommon", "page1"]
            });
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>appcommon.js会是这样:</p>

<pre><code>define(["jquery", "object", "event", "widget", "Dialog"],
function () {
    //Just an empty function, this is a place holder
    //module that will be optimized to include the
    //common depenendencies listed in this module's dependency array.
});
</code></pre>

<p>page1.js会是这样:</p>

<pre><code>define([ "jquery", "object", "event", "widget", "Dialog", "Tabs"],
function ($,        object,   event,   widget,   Dialog,   Tabs) {
    ...
});
</code></pre>

<p>page2.html 和 page2.js 看上去比较相似，除了应用"page2"而不是"page1"，以及在page2.js中使用"Slider"而不是"Tabs"。</p>

<p>build的配置文件, <strong>app.build.js</strong> 会是这样：</p>

<pre><code>({
    appDir: "webapp",
    baseUrl: "scripts",
    dir: "webapp-build",
    optimize: "none",
    modules: [
        {
            name: "appcommon"
        },
        {
            name: "page1",
            exclude: ["appcommon"]
        },
        {
            name: "page2",
            exclude: ["appcommon"]
        }
    ]
})
</code></pre>

<p>一旦build开始运行之后，它会创建类似于<strong>webapp</strong>的内容<strong>webapp-build</strong>，所不同的是这些内容是优化过的。appcommon.js 会包含公共的模块，page1.js会包含所有page1需要的模块，不包含appcommon以及他们的嵌套的模块依赖。</p>

<p><strong>priority</strong>配置值告诉 RequireJS 去并行加载 appcommon.js 以及 page1.js ，然后在跟踪依赖之前等待这两个文件被加载完毕。这两个文件，以及require.js，所有页面中的依赖会在3个请求内完成，appcommon.js和page1.js脚本是异步加载并且是并行的。</p>
</div>