<div id="directory" class="section">
<h1>RequireJS API</h1>

<ul class="index mono">
    <li class="hbox"><a href="#usage">用法</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 1-1.7</span></li>
        <ul>
            <li class="hbox"><a href="#jsfiles">加载JavaScript文件</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.1</span></li>
            <li class="hbox"><a href="#define">定义一个模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2</span></li>
            <ul>
                <li class="hbox"><a href="#defsimple">简单的Name/Value键值对</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.1</span></li>
                <li class="hbox"><a href="#deffunc">函数定义</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.2</span></li>
                <li class="hbox"><a href="#defdep">依赖函数定义</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.3</span></li>
                <li class="hbox"><a href="#funcmodule">将模块定义成函数</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.4</span></li>
                <li class="hbox"><a href="#cjsmodule">使用Simplified CommonJS Wrapper来定义模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.5</span></li>
                <li class="hbox"><a href="#modulename">定义一个有名字的模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.6</span></li>
                <li class="hbox"><a href="#modulenotes">其它有关模块的内容</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.7</span></li>
                <li class="hbox"><a href="#circular">循环依赖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.8</span></li>
            </ul>
            <li class="hbox"><a href="#i18n">定义一个I18N的包</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3</span></li>
            <li class="hbox"><a href="#text">使用文本文件作为依赖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.4</span></li>
            <li class="hbox"><a href="#jsonp">使用JSONP服务作为依赖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.5</span></li>
            <li class="hbox"><a href="#order">按指定顺序加载脚本文件</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.6</span></li>
            <li class="hbox"><a href="#pageload">页面加载事件支持/DOM Ready</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.7</span></li>
        </ul>
    <li class="hbox"><a href="#mechanics">Mechanics</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span></li>
    <li class="hbox"><a href="#config">配置参数</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span></li>
    <li class="hbox"><a href="#advanced">高级用法</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 4-4.5</span></li>
    <ul>
        <li class="hbox"><a href="#packages">从包中加载模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.1</span></li>
        <li class="hbox"><a href="#multiversion">多版本支持</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.2</span></li>
        <li class="hbox"><a href="#afterload">页面完成后加载代码</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.3</span></li>
        <li class="hbox"><a href="#webworker">Web Worker支持</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.4</span></li>
        <li class="hbox"><a href="#rhino">Rhino支持</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.5</span></li>
    </ul>
</ul>
</div>

<div class="section">
<h2>
<a name="usage">用法</a>
<span class="sectionMark">&sect; 1</span>
</h2>

<p>下面是五种使用require.js的基本方式。</p>

<ol>
<li>加载Javascript文件。</li>
<li>定义一个有着其它依赖项的模块。</li>
<li>定义一个全球化 (i18n) 的包。</li>
<li>指定一个文本依赖。</li>
<li>指定一个JSONP服务依赖。</li>
</ol>

<h3>
<a name="jsfiles">加载JavaScript文件</a>
<span class="sectionMark">&sect; 1.1</span>
</h3>

<p>如果你仅想加载一些JS文件，在HTML文档的头部加入以下代码：</p>

<pre><code>&lt;script src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script&gt;
    require(["some/module", "a.js", "b.js"], function(someModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    });
&lt;/script&gt;
</code></pre>

<p>在上面的依赖中，["some/module", "a.js", "b.js"], 会通过下面的scr值在script标签中被加载：</p>

<ul>
<li>some/module.js</li>
<li>a.js (在包含上面一段HTML代码的页面相同的路径下)</li>
<li>b.js (在包含上面一段HTML代码的页面相同的路径下)</li>
</ul>

<p>RequireJS通常使用<a href="#config-baseUrl">baseUrl</a> 和 <a href="#config-paths">paths</a> 配置来转换"some/module"这样的名字到一个真正的文件路径。</p>

<p>但是，如果依赖名字中含有下面属性，将会被看作一般文件路径，就像使用<script src>标签一样： &lt;script src=""&gt; 标签一样：</p>

<ul>
<li>以".js"结尾。</li>
<li>以"/"开头。</li>
<li>包含一个URL协义，像http:, https:。</li>
</ul>

<p>查看<a href="#config">配置参数</a>一节获得更多依赖查找路径的信息。</p>

<p>你可以在HTML文件中使用require() 作为一个标签，它很强大的可以被requirejs来加载。这允许优化工具很容易优化，并且这里有一个速记作为这种模式 被用在HTML中。这些救命可以像下面一样使用：</p>

<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<span class="note">data-main的路径规则在0.2.3中发生了发变。在这之前的版本，上面代码示例将变为：data-main="main"。</span>

<p>data-main属性告诉RequireJS去取data-main的属性值并且为为require([])调用。所以，在这个示例下，它将加载script/main.js，这个文件将包含一个顶级require调用：</p>

<pre><code>//Inside scripts/main.js
require(["some/module", "a.js", "b.js"], function(someModule) {
    //...
});
</code></pre>

<p>该包含data-main脚本的目录同时也是URL的根 (在RequireJS术语中称作<strong>baseUrl</strong>)去查找其它script that use the <strong>模块命名方案</strong>, 该方案中js不以.js结尾。the scheme that does not end a ".js" extension. In this example "some/module" is using the module naming scheme, where "a.js" and "b.js" are not.</p>

<p>Since data-main was used, and main.js is in the scripts directory, the baseUrl for RequireJS becomes the <strong>scripts</strong> directory. The <strong>"some/module"</strong> script would map to a path relative to the scripts directory. So it would be found at <strong>scripts/some/module.js</strong>.</p>

<p>记得这与第一个示例中‘some/module’的目录;some/module.js;不同。如果data-main不再使用，并且一个指定的baseURL值未在<a href="#config">RequireJS配置</a>中被传入，然后默认的baseUrl就是加载RequireJS的HTML所在目录。</p>

<p>脚本名称则是一般的路径以.js结尾，以/开始，或以协义开头被替换为相对于HTML页面而非baseUrl, just like HTML &lt;script&gt; src="" values. You can use the "module naming scheme" even if the script does not define a module, it is just means the path will be relative to baseUrl in that case.</p>

<h3>
<a name="define">定义一个模块</a>
<span class="sectionMark">&sect; 1.2</span>
</h3>

<p>模块和传统的被定义为很好包装的对象从而避免污染全局命名空间的脚本文件有着很大不同。它能它能知道自己的依赖并且得到一个处理在这些依赖而不需要依赖全局对象，除了替换recive依赖作为参数。。。模块在requireJS中作为 <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">Module Pattern</a>的扩展，有着不用其它全局依赖其它模块的优点。</p>

<p>RequireJS语法允许他们尽可能快的被加载，尽管用作顺序，但是也会考虑正顺的依赖顺序，尽管全局变量未被创建，它使得<a href="#multiversion">加载多同一模块的多版本</a>成为可能。</p>

<p>（如果你熟悉或正在使用CommonJS模块，请看下这一节<a href="commonjs.html">CommonJS Notes</a>，关于如何将RequireJS模块格式映射为CommonJS模块。）</p>

<p>There should only be <strong>one</strong> module definition per file on disk. The modules can be grouped into optimized bundles by the <a href="optimization.html">optimization tool</a>.</p>

<div class="subSection">
<h4>
<a name="defsimple">简单 Name/Value 键值对</a>
<span class="sectionMark">&sect; 1.2.1</span>
</h4>

<p>如果模块没有其它任何依赖，并且只是一个name/value的键值对集合，就可以传一个对象到define()中：</p>

<pre><code>//Inside file my/shirt.js:
define({
    color: "black",
    size: "unisize"
});
</code></pre>
</div>

<div class="subSection">
<h4>
<a name="deffunc">定义函数</a>
<span class="sectionMark">&sect; 1.2.2</span>
</h4>

<p>如果模块没有其它依赖，但需要使用一个函数来完成一些初始化工作，然后定义它自已，传一个函数到define()中：</p>

<pre><code>//my/shirt.js now does setup work
//before returning its module definition.
define(function () {
    //Do setup work here

    return {
        color: "black",
        size: "unisize"
    }
});
</code></pre>
</div>

<div class="subSection">
<h4><a name="defdep">定义一个有依赖的函数</a><span class="sectionMark">&sect; 1.2.3</span></h4>

<p>如果该模块有其它依赖，第一个参数应该是一个依赖名称的数组，第二个参数应是一个定义函数。该耿耿数会调用该模块的define一次，当加载完成时。该函数会返回一个对像。。。。依赖会作为函数参数传给定义函数，和依赖数组有着相同的顺序。</p>

<pre><code>//my/shirt.js now has some dependencies, a cart and inventory
//module in the same directory as shirt.js
define(["./cart", "./inventory"], function(cart, inventory) {
        //return an object to define the "my/shirt" module.
        return {
            color: "blue",
            size: "large",
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
);
</code></pre>

<p>在这个示例中，一个 my/shirt的模块被创建。它依赖于一个 car和 inventory。在硬盘上，这些文件有着下面的结构：</p>

<ul>
<li>my/cart.js</li>
<li>my/inventory.js</li>
<li>my/shirt.js</li>
</ul>

<p>这个方法调用上面定义的两个参数。 cart 和 inventory。 这两个模块用./ 的模块名。</p>

<p>这个函数直到cart…模块被加载完之后才会被调用，函数接收cart inventory参数作为模块。</p>

<p>模块定义全局是不被推荐的，所以一个模块的多个版本能同时存在一个页面。所以，函数参数和配依赖顺序应一致。</p>

<p>return对应调用shirt 模块定义。通过这种方式的模块定义，shirt不以一种全局对象存在。</p>
</div>

<div class="subSection">
<h4><a name="funcmodule">将模块定义成一个函数</a><span class="sectionMark">&sect; 1.2.4</span></h4>

<p>模块不是必须要有一个return对象。函数中任意有效的返回值都有效。这里有一个模块返回一个函数作为模块定义：</p>

<pre><code>//A module definition inside foo/title.js. It uses
//my/cart and my/inventory modules from before,
//but since foo/bar.js is in a different directory than
//the "my" modules, it uses the "my" in the module dependency
//name to find them. The "my" part of the name can be mapped
//to any directory, but by default, it is assumed to be a
//sibling to the "foo" directory.
define(["my/cart", "my/inventory"],
    function(cart, inventory) {
        //return a function to define "foo/title".
        //It gets or sets the window title.
        return function(title) {
            return title ? (window.title = title) :
                   inventory.storeName + ' ' + cart.name;
        }
    }
);
</code></pre>
</div>


<div class="subSection">
<h4><a name="cjsmodule">以Simplified CommonJS Wrapper的方式定义模块</a><span class="sectionMark">&sect; 1.2.5</span></h4>

<p>如果你想重用之前写过的一些代码<a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS module format</a>，在依赖数组方面将有很大麻烦。所以，Node0.5将支持一个有限的defin()函数支提供Commonjs的简单包装。所以你想构建一个小型的功能块并且你想让它即能工作在node，同时也能在浏览器上跑，你可以使用scw。If you wish to reuse some code that was written in the traditional <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS module format</a> it may be difficult to re-work to the array of dependencies used above. Also, Node 0.5 will likely support a limited kind of define() function that provides a simple wrapper over CommonJS files. So if you are building a small utility and you wish it to be used in both Node (without using the <a href="node.html">RequireJS Node adapter</a>), and in the browser, you can use the <a href="commonjs.html">simplified CommonJS wrapper</a>.</p>

<p>如果你有很多依赖，它会非常有用，保持依赖数据位置同步，如果function参数位置未被指定。</p>

<p>这个包装器依赖于Function.prototype.toString()给出一个有效function内容字符值。这在一些设备如PS3和都的浏览器中不被技持。。其它设备中使用<a href="optimization.html">optimizer</a>去按数组格式去拉依赖。</p>
</div>


<div class="subSection">
<h4><a name="modulename">定义一个有名字的模块</a><span class="sectionMark">&sect; 1.2.6</span></h4>

<p>你或许遇到一些define()中包含一个名字作为模块在第一个define参数中：</p>

<pre><code>    //Explicitly defines the "foo/title" module:
    define("foo/title",
        ["my/cart", "my/inventory"],
        function(cart, inventory) {
            //Define foo/title object in here.
       }
    );
</code></pre>

<p>这是<a href="optimization.html">optimization tool</a>中所生成的。你可以指定模块名，但它使得模块弱。。。如果你移动这个模块从一个目录到另一个目录，你不得不发它的名字。这里最好避免为模块起名，就让op tool生成模块名字好了。op tool需要添加名字从而不只一个模块在一个文件中，让浏览器更快的加载。</p>
</div>

<div class="subSection">

<h4><a name="modulenotes">Other Module Notes</a><span class="sectionMark">&sect; 1.2.7</span></h4>

<p id="modulenotes-onemodule"><strong>One module per file.</strong>: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. Multiple modules will be grouped into optimized files by the <a href="optimization.html">optimization tool</a>, but you should only use the optimization tool to place more than one module in a file.</p>

<p id="modulenotes-relative"><strong>Relative module names inside define()</strong>: For require("./relative/name") calls that can happen inside a define() function call, be sure to ask for "require" as a dependency, so that the relative name is resolved correctly:</p>

<pre><code>define(["require", "./relative/name"], function(require) {
    var mod = require("./relative/name");
});
</code></pre>

<p>Or better yet, use the shortened syntax that is available for use with <a href="commonjs.html">translating CommonJS</a> modules:</p>

<pre><code>define(function(require) {
    var mod = require("./relative/name");
});
</code></pre>

<p>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with "require", so the code will work correctly with relative paths.</p>

<p id="modulenotes-urls"><strong>Generate URLs relative to module</strong>: You may need to generate an URL that is relative to a module. To do so, ask for "require" as a dependency and then use require.toUrl() to generate the URL:</p>

<pre><code>define(["require"], function(require) {
    var cssUrl = require.toUrl("./style.css");
});
</code></pre>

<p id="modulenotes-console"><strong>Console debugging</strong>: If you need to work with a module you already loaded via a require(["module/name"], function(){}) call in the JavaScript console, then you can use  the require() form that just uses the string name of the module to fetch it:</p>

<pre><code>require("module/name").callSomeFunction()
</code></pre>

<p>Note this only works if "module/name" was previously loaded via the async version of require: require(["module/name"]). If using a relative path, like './module/name', those only work inside define</p>
</div>

<div class="subSection">
<h4><a name="circular">循环依赖</a><span class="sectionMark">&sect; 1.2.8</span></h4>

<p>如果你定义了一个循环依赖（A依赖B然后B回过来依赖A），这种场景下，当B的模块函数被调用，它将得到一个未定义的A。B能取得A晚一会通过使用require()方法（确保指定require作为依赖，正确的上下文被用作于找到A）：</p>

<pre><code>//Inside B.js:
define(["require", "A"],
    function(require, a) {
        //"a" in this case will be null if A also asked for B,
        //a circular dependency.
        return function(title) {
            return require("A").doSomething();
        }
    }
);
</code></pre>

<p>一般情况下，你不需要使用require去获取模块，但是依赖于模块传入一个参数，循环依赖是一个特例，这种情况下require()则可以解决问题。</p>

<p>如果你熟悉CommonJS模块，你可以使用<strong>exports</strong>作为依赖，去为模块创建空对象。在循环依赖两侧都做这些，你可以安全的在其它参数中使用函数参数。</p>
</div>

<h3><a name="i18n">Define an I18N Bundle</a><span class="sectionMark">&sect; 1.3</span></h3>

<p>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</p>

<p>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</p>

<p>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). <a href="download.html#i18n">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>

<p>To define a bundle, put it in a directory called "nls" -- the i18n! plugin assumes a module name with "nls" in it indicates an i18n bundle. The "nls" marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your "my" set of modules, create the directory structure like so:</p>

<ul>
<li>my/nls/colors.js</li>
</ul>

<p>The contents of that file should look like so:</p>

<pre><code>//my/nls/colors.js contents:
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    }
});
</code></pre>

<p>An object literal with a property of "root" defines this module. That is all you have to do to set the stage for later localization work.</p>

<p>You can then use the above module in another module, say, in a my/lamps.js file:</p>

<pre><code>//Contents of my/lamps.js
define(["i18n!my/nls/colors"], function(colors) {
    return {
        testMessage: "The name for red in this locale is: " + colors.red
    }
});
</code></pre>

<p>The my/lamps module has one property called "testMessage" that uses colors.red to show the localized value for the color red.</p>

<p>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</p>

<pre><code>//Contents of my/nls/colors.js
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    },
    "fr-fr": true
});
</code></pre>

<p>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</p>

<pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "red": "rouge",
    "blue": "bleu",
    "green": "vert"
});
</code></pre>

<p>RequireJS will use the browser's navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the locale: configuration parameter (see the <a href="#config">Configuration options</a> section).</p>

<p><strong>Note</strong> that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</p>

<p>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is "en-us", then the "root" bundle will be used. If the locale is "fr-fr-paris" then the "fr-fr" bundle will be used.</p>

<p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p>

<pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "blue": "bleu",
    "green": "vert"
});
</code></pre>

<p>Then the value for red in "root" will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</p>

<ul>
<li>my/nls/fr-fr-paris/colors.js</li>
<li>my/nls/fr-fr/colors.js</li>
<li>my/nls/fr/colors.js</li>
<li>my/nls/colors.js</li>
</ul>

<p>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</p>

<pre><code>//my/nls/colors.js contents:
define({
    "root": true,
    "fr-fr": true,
    "fr-fr-paris": true
});
</code></pre>

<p>and the root bundle would look like:</p>

<pre><code>//Contents of my/nls/root/colors.js
define({
    "red": "red",
    "blue": "blue",
    "green": "green"
});
</code></pre>

<h3><a name="text">Specify a Text File Dependency</a><span class="sectionMark">&sect; 1.4</span></h3>

<p>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</p>

<p>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. <a href="download.html#text">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>

<p>You can specify a text file resource as a dependency like so:</p>

<pre><code>require(["some/module", "text!some/module.html", "text!some/module.css"],
    function(module, html, css) {
        //the html variable will be the text
        //of the some/module.html file
        //the css variable will be the text
        //of the some/module.css file.
    }
);
</code></pre>

<p>Notice the .html and .css suffixes to specify the extension of the file. The "some/module" part of the path will be resolved according to normal module name resolution: it will use the <strong>baseUrl</strong> and <strong>paths</strong> <a href="#config">configuration options</a> to map that name to a path.</p>

<p>For HTML/XML/SVG files, there is another option. You can pass !strip, which strips XML declarations so that external SVG and XML documents can be added to a document without worry. Also, if the string is an HTML document, only the part inside the body tag is returned. Example:</p>

<pre><code>require(["text!some/module.html!strip"],
    function(html) {
        //the html variable will be the text of the
        //some/module.html file, but only the part
        //inside the body tag.
    }
);
</code></pre>

<p>The text files are loaded via asynchronous XMLHttpRequest (XHR) calls, so you can only fetch files from the same domain as the web page.</p>

<p>However, the build system for RequireJS will inline any text! references with the actual text file contents into the modules, so after a build, the modules that have text! dependencies can be used from other domains.</p>

<h3><a name="jsonp">Specify a JSONP Service Dependency</a><span class="sectionMark">&sect; 1.5</span></h3>

<p><a href="http://en.wikipedia.org/wiki/JSON#JSONP">JSONP</a> is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</p>

<p>To use a JSONP service in RequireJS, specify "define" as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</p>

<p>Here is an example that calls a JSONP API endpoint. In this example, the JSONP callback parameter is called "callback", so "callback=define" tells the API to wrap the JSON response in a "define()" wrapper:</p>

<pre><code>require(["http://example.com/api/data.json?callback=define"],
    function (data) {
        //The dta object will be the API response for the
        //JSONP data call.
        console.log(data);
    }
);
</code></pre>

<p>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</p>

<p><strong>Only JSONP return values that are JSON objects are supported</strong>. A JSONP response that is an array, a string or a number will not work.</p>

<p>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</p>

<p>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override require.onError() to get errors. The error object passed to the onerror function will contain two properties if it is a timeout issue:</p>

<ul>
<li><strong>requireType</strong>: value will be "timeout"</li>
<li><strong>requireModules</strong>: an array of module names/URLs that timed out. You can find the JSONP service URL in here.</li>
</ul>

<p>Note however that if you get this type of error it probably means other modules you defined via define() did not get executed, and the scripts you want to use may not be available.</p>

<h3><a name="order">Load Scripts in a Specific Order</a><span class="sectionMark">&sect; 1.6</span></h3>

<p>Normally RequireJS loads and evaluates scripts in an undetermined order. However, there are some traditional scripts that depend on being loaded in a specific order. For those cases you can use the <strong>order</strong> plugin. <a href="download.html#order">Download the plugin</a> and put it in the same directory as your app's main JS file. Example usage:</p>

<pre><code>require(["order!one.js", "order!two.js", "order!three.js"], function () {
    //This callback is called after the three scripts finish loading.
});
</code></pre>

<p>Scripts loaded by the <strong>order</strong> plugin will be fetched asynchronously, but evaluated in the order they are passed to require, so it should still perform better than using script tags in the head of an HTML document.</p>

<p>The <strong>order</strong> plugin is best used with traditional scripts. It is not needed for scripts that use define() to define modules. It is possible to mix and match "order!" dependencies with regular dependencies, but only the "order!" ones will be evaluated in relative order to each other. </p>

<p><strong>Notes:</strong></p>
<ul>
    <li>The order! plugin only works with JavaScript files that are cacheable by the browser. If the JS file has headers that do not allow the browser to cache the file, then the order of scripts will not be maintained.</li>
    <li>Do not use the order! plugin to load other plugin-loaded resources. For instance. 'order!cs!my/coffescript/module' is not recommended. You will get errors in some versions of IE and WebKit. This is due to the workarounds the order plugin needs to do for those browsers to ensure ordered execution.</li>
</ul>


<h3><a name="pageload">Page Load Event Support/DOM Ready</a><span class="sectionMark">&sect; 1.7</span></h3>

<p>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</p>

<p>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. <a href="download.html#domReady">Download the module</a> and use it in your project like so:</p>

<pre><code>require(['domReady'], function (domReady) {
  domReady(function () {
    //This function is called once the DOM is ready.
    //It will be safe to query the DOM and manipulate
    //DOM nodes in this function.
  }):
});
</code></pre>

<p>Since DOM ready is a common application need, ideally the nested functions
in the API above could be avoided. The domReady module also implements the <a href="plugin.html">Loader Plugin API</a>,
so you can use the loader plugin syntax (notice the <b>!</b> in the domReady dependency) to force the
require() callback function to wait for the DOM to be ready before executing. domReady will return
the current document when used as a loader plugin:</p>

<pre><code>require(['domReady!'], function (doc) {
    //This function is called once the DOM is ready,
    //notice the value for 'domReady!' is the current
    //document.
  }):
});
</code></pre>

<p><b>Note:</b> If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS "timeout" error. If this a problem either increase the <a href="#config-waitSeconds">waitSeconds</a> configuration, or just use domReady as a module and
call domReady() inside the require() callback.</p>

<p id="domReadyWithResources"><b>DOM Ready with implicit dependencies</b>: If you are working on a project that does not use require() and define() to explicitly indicate dependencies in all scripts, you many notice some errors when waiting for the DOM to be ready then executing code that depends on those implicit dependencies.</p>

<p>The best fix is to wrap all scripts in explicit define() calls that specify all the direct dependencies. However, if that is not an option, you can call a special method on the domReady plugin to wait for all scripts to load and the DOM to be ready:</p>

<pre><code>require(['domReady'], function (domReady) {
  domReady.withResources(function () {
    //This function is called once the DOM is ready,
    //and all modules/plugin resources that RequireJS is loading
    //finish loading.
  }):
});
</code></pre>

<p><b>You should avoid using this function</b>, and instead be very explicit about the dependencies in each file.
However, as an intermediate patch to get a project working with RequireJS, it can be useful.</p>

</div>

<div class="section">
<h2>
<a name="mechanics">Mechanics</a>
<span class="sectionMark">&sect; 2</span>
</h2>

<p>RequireJS loads each dependency as a script tag, using head.appendChild().</p>

<p>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions in the right order.</p>

<p>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</p>

<p>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</p>
</div>

<div class="section">
<h2>
<a name="config">Configuration Options</a>
<span class="sectionMark">&sect; 3</span>
</h2>

<p>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</p>

<pre><code>&lt;script type="text/javascript" src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15,
    locale: "fr-fr"
  });
  require( ["some/module", "my/module", "a.js", "b.js"],
    function(someModule,    myModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    }
  );
&lt;/script&gt;
</code></pre>

<p>Also, you can define require to be an object <strong>before</strong> require.js is
loaded, and have the values applied.
This example specifies some dependencies to load as soon as require.js defines require():</p>

<pre><code>&lt;script type="text/javascript"&gt;
    var require = {
        deps: ["some/module1", "my/module2", "a.js", "b.js"],
        callback: function(module1, module2) {
            //This function will be called when all the dependencies
            //listed above in deps are loaded. Note that this
            //function could be called before the page is loaded.
            //This callback is optional.
        }
    };
&lt;/script&gt;
&lt;script type="text/javascript" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<p><b>Note:</b> It is best to use <code>var require = {}</code> and do not use
<code>window.require = {}</code>, it will not behave correctly in IE.</p>

<p>Supported configuration options:</p>

<p id="config-baseUrl"><strong>baseUrl</strong>: the root path to use for all module lookups. So in the above example, "my/module"'s script tag will have a src="/another/path/my/module.js". baseUrl is <strong>not</strong> used when loading plain .js files, those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</p>

<p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a <strong>data-main</strong> attribute is used, that path will become the baseUrl.</p>

<p>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</p>

<p id="config-paths"><strong>paths</strong>: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a "/" or has a URL protocol in it ("like http:"). In those cases, the path is determined relative to baseUrl. Using the above sample config, "some/module"'s script tag will be src="/another/path/some/v1.0/module.js". The path that is used for a module name should <strong>not</strong> include the .js extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path.</p>

<p id="config-packagePaths"><strong>packagePaths</strong>: configures module name prefixes to map to CommonJS packages. See the <a href="#packages">packages topic</a> for more information. Related to <strong>packages</strong> config option.</p>

<p id="config-packages"><strong>packages</strong>: configures loading modules from CommonJS packages. See the <a href="#packages">packages topic</a> for more information. Related to <strong>packagePaths</strong> config option.</p>

<p id="config-waitSeconds"><strong>waitSeconds</strong>: The number of seconds to wait before giving up on loading a script. The default is 7 seconds.</p>

<p id="config-locale"><strong>locale</strong>: The locale to use for loading i18n bundles. By default navigator.language or navigator.userLanguage will be used. The proper syntax for specifying a locale is using lowercase and separating values by dashes, for instance: "fr-fr-paris" or "en-us".</p>

<p id="config-context"><strong>context</strong>: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the <a href="#multiversion">Multiversion Support</a> section.</p>

<p id="config-deps"><strong>deps</strong>: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined.</p>

<p id="config-callback"><strong>callback</strong>: A function to pass to require that should be require after <strong>deps</strong> have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's <strong>deps</strong> array has been loaded.</p>

<p id="config-priority"><strong>priority</strong>: An array of module/file names to load immediately, before tracing down any other dependencies. This allows you to set up a small set of files that are downloaded in parallel that contain most of the modules and their dependencies already built in. More information is in the <a href="faq-optimization.html#priority">Optimization FAQ, Priority Downloads</a>.<b>Note:</b> resources loaded by loader plugins (like 'text!template.html') <b>cannot</b> be specified in the priority array: the priority mechanism only works with regular JavaScript resources.</p>

<p id="config-xhtml"><strong>xhtml</strong>: If set to true, document.createElementNS() will be used to create script elements.</p>

<p id="config-urlArgs"><strong>urlArgs</strong>: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</p>

<pre><code>urlArgs: "bust=" +  (new Date()).getTime()
</code></pre>

<p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p>

<p id="config-jQuery"><strong>jQuery</strong>: (RequireJS 0.25.0+) specify an exact version match for the version of jQuery that should be allowed to register as the 'jquery' dependency. This is useful in environments where multiple jQuery files could be loaded but you want
to be sure to get the right version of jQuery for your loading context. Normally you do not need to set this if you are only loading one version of jQuery in a page. However, if you use third party libraries that may also load jQuery, it is best to set this option.</p>

<p id="config-catchError"><strong>catchError</strong>: (RequireJS 0.26.0+) Normally, errors evaluating define() factory functions are not caught, to allow easy debugging during development. However, for some scenarios and production deployments, it is useful to have the errors caught. By specifying catchError.define = true, the errors will be caught and passed to require.onError(). Normally require.onError() throws the error, but you can override the definition of require.onError() to do something different.</p>

</div>

<div class="section">
<h2>
<a name="advanced">Advanced Usage</a>
<span class="sectionMark">&sect; 4</span>
</h2>

<h3><a name="packages">Loading Modules from Packages</a><span class="sectionMark">&sect; 4.1</span></h3>

<p>RequireJS supports loading modules that are in a <a href="http://wiki.commonjs.org/wiki/Packages/1.1">CommonJS Packages</a> directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</p>

<ul>
<li>A package can be associated with a module name/prefix.</li>
<li>The package config can specify the following properties for a specific package:
<ul>
<li><strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li>
<li><strong>location</strong>: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</li>
<li><strong>main</strong>: The name of the module inside the package that should be used when someone does a require for "packageName". The default value is "main", so only specify it if it differs from the default. The value is relative to the package folder.</li>
</ul></li>
</ul>

<p><strong>IMPORTANT NOTES</strong></p>

<ul>
<li>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the <a href="commonjs.html#autoconversion">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li>
<li>The <strong>lib</strong> directory option that may be used in packages is not supported. It causes some confusing path issues.</li>
<li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href="#multiversion">multiversion support</a> to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</li>
</ul>

<p>If you use a similar project layout as specified in the <a href="start.html">Start Guide</a>, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>There are two types of packages you may use in your project -- packages made by other people (third-party packages), and packages that you make as part of your project (source packages). It is suggested that you use two different directories inside scripts to keep track of them. For third-party packages, a <strong>.packages</strong> is recommended, where source packages can just be directories that are siblings to require.js. The third-party packages likely do not need to be committed to your source control, so you can put .packages in your source control's ignore file (.gitignore, .hgignore, etc...).</p>

<p>However, you will want to remember what third-party packages you are using, and where you got them. For that reason, it is suggested that you construct a <strong>package.json</strong> file in the <strong>scripts</strong> directory and use a <a href="http://wiki.commonjs.org/wiki/Packages/Mappings"><strong>mappings</strong></a> section in the package.json file to remember the locations.</p>

<p>Here is how the example directory layout looks with two third-party packages, <strong>alpha</strong> and <strong>omega</strong>, and has two source packages, <strong>cart</strong> and <strong>store</strong>:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>.gitignore (ignores .packages)</li>
<li>.packages/
<ul>
<li>alpha/
<ul>
<li>main.js</li>
</ul></li>
<li>omega/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>main.js</li>
</ul></li>
<li>store/
<ul>
<li>main.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>The <strong>package.json</strong> for the project might be as simple as this, just to track where alpha and omega came from, since they are not committed to source control:</p>

<pre><code>{
    "mappings": {
        "alpha": "http://example.com/packages/alpha/0.4.zip",
        "omega": "http://example.com/pacakges/omega/1.0.zip"
    }
}
</code></pre>

<p><strong>project.html</strong> will have a script tag like this:</p>

<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong> uses the <strong>packagePaths</strong> config option to set up the location of the the third party packages, where "packages" is used to set up packages that are relative to require.js, which in this case are the source packages "cart" and "store":</p>

<pre><code>//main.js contents
//Pass a config object to require
require.config({
    packagePaths: {
        ".packages": ["alpha", "omega"]
    },
    "packages": ["cart", "store"]
});

require(["alpha", "omega", "cart", "store", "store/util"],
function (alpha,   omega,   cart,   store,   util) {
    //use the modules as usual.
});
</code></pre>

<p>A require of "alpha" means that it will be loaded from <strong>scripts/.packages/alpha/main.js</strong>, since "main" is the default main module setting supported by RequireJS. A require of "store/util" will be loaded from <strong>scripts/store/util.js</strong>.</p>

<p>If the "alpha" and "store" packages did not follow the "main.js" convention, and looked more like this:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>.gitignore (ignores .packages)</li>
<li>.packages/
<ul>
<li>alpha/
<ul>
<li>index.js</li>
</ul></li>
<li>omega/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>main.js</li>
</ul></li>
<li>store/
<ul>
<li>store.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>Then the RequireJS configuration would look like so:</p>

<pre><code>require.config({
    packagePaths: {
        ".packages": [
            {
                name: "alpha",
                main: "index"
            },
            "omega"
        ]
    },
    "packages": [
        "cart",
        {
            name: "store",
            main: "store"
        }
    ]
});
</code></pre>

<p><strong>packagePaths</strong> is just a convenience for listing several packages that are not direct siblings of require.js, but still have a common directory parent. The above configuration could be written like so with just the <strong>packages</strong> config option, by using the <strong>location</strong> property for each third-party package:</p>

<pre><code>require.config({
    "packages": [
        {
            name: "alpha",
            location: ".packages/alpha",
            main: "index"
        },
        {
            name: "omega",
            location: ".packages/omega"
        }
        "cart",
        {
            name: "store",
            main: "store"
        }
    ]
});
</code></pre>

<p>To avoid verbosity, it is strongly suggested to always use packages that use "main" convention in their structure, and use packagePaths for third party packages.</p>

<p>To make fetching and configuring packages easier, there are designs for a command line package tool in the works.</p>

<h3><a name="multiversion">Multiversion Support</a><span class="sectionMark">&sect; 4.2</span></h3>

<p>As mentioned in <a href="#config">Configuration Options</a>, multiple versions of a module can be loaded in a page by using different "context" configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</p>

<pre><code>&lt;script type="text/javascript" src="../require.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});

reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
             omega.version); //prints 1
      }
    );
  }, 100);
});

var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });

reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
&lt;/script&gt;
</code></pre>

<p>Note that "require" is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If "require" is not specified as a dependency, then there will likely be an error.</p>

<h3><a name="afterload">Loading Code After Page Load</a><span class="sectionMark">&sect; 4.3</span></h3>

<p>The example above in the <strong>Multiversion Support</strong> section shows how code can later be loaded by nested require() calls. </p>

<h3><a name="webworker">Web Worker Support</a><span class="sectionMark">&sect; 4.4</span></h3>

<p>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</p>

<p>You will likely need to set the <strong>baseUrl</strong> <a href="#config">configuration option</a> to make sure require() can find the scripts to load.</p>

<p>You can see an example of its use by looking at one of the files used in <a href="http://github.com/jrburke/requirejs/blob/master/tests/workers.js">the unit test</a>.</p>

<h3><a name="rhino">Rhino Support</a><span class="sectionMark">&sect; 4.5</span></h3>

<p>RequireJS can be used in Rhino via the <a href="download.html#rjs">r.js adapter</a>.
See <a href="https://github.com/jrburke/r.js/blob/master/README.md">the r.js README</a> for more information.</p>
</div>
