<!DOCTYPE html>
<html>
<head>
    <title>RequireJS API</title>

    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    
    <link rel="stylesheet" type="text/css" href="../main.css">
    <link rel="icon" type="image/x-icon" href="/favicon.png">
    <!--[if IE]> <link rel="stylesheet" type="text/css" href="../ie.css" /> <![endif]-->
    <link rel="stylesheet" type="text/css" href="http://ajax.googleapis.com/ajax/libs/dojo/1.4/dojox/highlight/resources/highlight.css">

    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
    <script type="text/javascript" src="../init.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/dojo/1.4/dojo/dojo.xd.js"></script>
    <script type="text/javascript">
        dojo.require("dojox.highlight");
        dojo.require("dojox.highlight.languages.javascript");
        dojo.require("dojox.highlight.languages.html");
        dojo.ready(function() {
            dojo.query("pre > code")
                .forEach(function(node) {
                    if (node.innerHTML.indexOf("DOCTYPE") !== -1 || node.innerHTML.indexOf('&lt;script') !== -1) {
                        dojo.addClass(node, "html");
                    } else {
                        dojo.addClass(node, "javascript");
                    }
                })
                .forEach(dojox.highlight.init);
        });
    </script>
</head>
<body>
<div id="grid"></div>
<div id="wrapper">

    <div id="navBg"></div>
    <div id="nav" class="mono">
        <a class="homeImageLink" href="../"></a>
        <h1>a javascript module loader</h1>

        <ul>
            <li class="hbox">
                <a href="../">主页</a>
                <span class="spacer boxFlex"></span>
                <span class="icon home"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="start.html">开始</a>
                <span class="spacer boxFlex"></span>
                <span class="icon start"></span>
            </li>
            <li class="hbox">
                <a class="local" href="download.html">下载</a>
                <span class="spacer boxFlex"></span>
                <span class="icon download"></span>
            </li>
            <li class="hbox">
                <a class="local" href="api.html">API</a>
                <span class="spacer boxFlex"></span>
                <span class="icon api"></span>
            </li>
            <li class="hbox">
                <a class="local" href="optimization.html">优化</a>
                <span class="spacer boxFlex"></span>
                <span class="icon optimize"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="jquery.html">结合jQuery一起使用</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="node.html">结合Node一起使用</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="dojo.html">结合Dojo一起使用</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="commonjs.html">CommonJS备注</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="faq.html">FAQs</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="errors.html">常见错误</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="plugins.html">写一个插件</a>
                <span class="spacer boxFlex"></span>
                <span class="icon api"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="why.html">为什么需要Web模块化</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="whyamd.html">为什么需要AMD</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="requirements.html">需求</a>
                <span class="spacer boxFlex"></span>
                <span class="icon requirement"></span>
            </li>
            <li class="hbox">
                <a class="local" href="history.html">历史版本</a>
                <span class="spacer boxFlex"></span>
                <span class="icon history"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a href="http://groups.google.com/group/requirejs">需要帮助</a>
                <span class="spacer boxFlex"></span>
                <span class="icon help"></span>
            </li>
            <li class="hbox">
                <a href="http://tagneto.blogspot.com">作者博客</a>
                <span class="spacer boxFlex"></span>
                <span class="icon blog"></span>
            </li>
            <li class="hbox">
                <a href="http://twitter.com/jrburke">Twitter</a>
                <span class="spacer boxFlex"></span>
                <span class="icon twitter"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a href="http://github.com/jrburke/requirejs">GitHub</a>
                <span class="spacer boxFlex"></span>
                <span class="icon git"></span>
            </li>
            <li class="hbox">
                <a class="local" href="contributing.html">贡献</a>
                <span class="spacer boxFlex"></span>
                <span class="icon fork"></span>
            </li>
            <li class="hbox">
                <a class="local" href="translate.html">中文翻译</a>
                <span class="spacer boxFlex"></span>
                <span class="icon fork"></span>
            </li>
        </ul>

        <ul>
            <li class="version">1.0.3 文档</li>
        </ul>
    </div>

    <div id="content"><div id="directory" class="section">
<h1>RequireJS API</h1>

<ul class="index mono">
    <li class="hbox"><a href="#usage">用法</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 1-1.7</span></li>
        <ul>
            <li class="hbox"><a href="#jsfiles">加载JavaScript文件</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.1</span></li>
            <li class="hbox"><a href="#define">定义一个模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2</span></li>
            <ul>
                <li class="hbox"><a href="#defsimple">简单的Name/Value键值对</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.1</span></li>
                <li class="hbox"><a href="#deffunc">函数定义</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.2</span></li>
                <li class="hbox"><a href="#defdep">依赖函数定义</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.3</span></li>
                <li class="hbox"><a href="#funcmodule">将模块定义成函数</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.4</span></li>
                <li class="hbox"><a href="#cjsmodule">使用Simplified CommonJS Wrapper来定义模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.5</span></li>
                <li class="hbox"><a href="#modulename">定义一个有名字的模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.6</span></li>
                <li class="hbox"><a href="#modulenotes">其它有关模块的内容</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.7</span></li>
                <li class="hbox"><a href="#circular">循环依赖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.2.8</span></li>
            </ul>
            <li class="hbox"><a href="#i18n">定义一个I18N的包</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.3</span></li>
            <li class="hbox"><a href="#text">使用文本文件作为依赖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.4</span></li>
            <li class="hbox"><a href="#jsonp">使用JSONP服务作为依赖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.5</span></li>
            <li class="hbox"><a href="#order">按指定顺序加载脚本文件</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.6</span></li>
            <li class="hbox"><a href="#pageload">页面加载事件支持/DOM Ready</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1.7</span></li>
        </ul>
    <li class="hbox"><a href="#mechanics">Mechanics</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span></li>
    <li class="hbox"><a href="#config">配置参数</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span></li>
    <li class="hbox"><a href="#advanced">高级用法</a><span class="spacer boxFlex"></span><span class="sect">&sect;&sect; 4-4.5</span></li>
    <ul>
        <li class="hbox"><a href="#packages">从包中加载模块</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.1</span></li>
        <li class="hbox"><a href="#multiversion">多版本支持</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.2</span></li>
        <li class="hbox"><a href="#afterload">页面完成后加载代码</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.3</span></li>
        <li class="hbox"><a href="#webworker">Web Worker支持</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.4</span></li>
        <li class="hbox"><a href="#rhino">Rhino支持</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4.5</span></li>
    </ul>
</ul>
</div>

<div class="section">
<h2>
<a name="usage">用法</a>
<span class="sectionMark">&sect; 1</span>
</h2>

<p>下面是五种使用require.js的基本方式。</p>

<ol>
<li>加载Javascript文件。</li>
<li>定义一个有着其它依赖项的模块。</li>
<li>定义一个全球化 (i18n) 的包。</li>
<li>指定一个文本依赖。</li>
<li>指定一个JSONP服务依赖。</li>
</ol>

<h3>
<a name="jsfiles">加载JavaScript文件</a>
<span class="sectionMark">&sect; 1.1</span>
</h3>

<p>如果你仅想加载一些JavaScript文件，在HTML文档的HEAD标签处加入以下代码：</p>

<pre><code>&lt;script src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script&gt;
    require(["some/module", "a.js", "b.js"], function(someModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    });
&lt;/script&gt;
</code></pre>

<p>在上面的依赖中，["some/module", "a.js", "b.js"]，会通过下面的src值在script标签处被加载：</p>

<ul>
<li>some/module.js</li>
<li>a.js (在包含上面一段HTML代码的页面相同的路径下)</li>
<li>b.js (在包含上面一段HTML代码的页面相同的路径下)</li>
</ul>

<p>RequireJS通常使用<a href="#config-baseUrl">baseUrl</a> 和 <a href="#config-paths">paths</a> 配置来转换"some/module"这样的名字到一个真正的文件路径。</p>

<p>但是，如果依赖名字中含有下面属性，将会被看作一般文件路径，就像使用&lt;script src=""&gt; 标签一样：</p>

<ul>
<li>以".js"结尾。</li>
<li>以"/"开头。</li>
<li>包含一个URL协义，像http:, https:。</li>
</ul>

<p>查看<a href="#config">配置参数</a>一节获得更多依赖查找路径的信息。</p>

<p>你可以在HTML文件script标签中使用require()，这是RequireJS最推荐的加载文件的方式。这使得优化工具很容易优化，这种模式可以通过班下面一种快捷方式来实现。上面的示例转变为如下结构：

<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<span class="note">data-main的路径规则在0.2.3中发生了发变。在这之前的版本，上面代码示例将是：data-main="main"。</span>

<p>data-main属性告诉RequireJS去取data-main的属性值然后用require([])的方式调用。所以，在这个示例下，它将加载script/main.js，这个文件中应包含一个顶级require调用：</p>

<pre><code>//Inside scripts/main.js
require(["some/module", "a.js", "b.js"], function(someModule) {
    //...
});
</code></pre>

<p>该包含data-main脚本的目录同时也作为URL的根 (在RequireJS术语中称作<strong>baseUrl</strong>)去查找其它使用 <strong>模块命名方案</strong>和脚本, 该方案中js不以.js结尾。本示例中 "some/module" 使用了这种命名方案，而 "a.js" 和 "b.js" 则没有。</p>

<p>data-main 已经介绍过了，main.js也在scripts目录，RequireJS的baseUrl转变成<strong>scripts</strong> 目录。<strong>"some/module"</strong> 脚本将以scruots目录作为相对地址进行映射。就是说这个文件应该在<strong>scripts/some/module.js</strong>.</p>

<p>记得这与第一个示例中‘some/module’对应到some/module.js文件有所不同。如果没有使用data-main，并且一个指定的baseURL值未在<a href="#config">RequireJS配置</a>中被传入，这种情况下默认的baseUrl就是加载RequireJS的HTML所在目录。</p>

<p>以.js结尾，/开始，或以协义开头的一般路径，则会被映射为相对于HTML页面而非baseUrl，就像在HTML中的&lt;script&gt; src="" 值的查找方式一样。你可以使用 "模块命名方案" 尽管那个脚本并没有定义一个模块，这意味着路径会相对于baseUrl来查找。</p>

<h3>
<a name="define">定义一个模块</a>
<span class="sectionMark">&sect; 1.2</span>
</h3>

<p>模块和传统的被定义为很好包装的对象从而避免污染全局命名空间的脚本文件有着很大不同。它能它能知道自己的依赖并且得到一个处理在这些依赖而不需要依赖全局对象，除了替换recive依赖作为参数。。。模块在requireJS中作为 <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">Module Pattern</a>的扩展，有着不用其它全局依赖其它模块的优点。</p>

<p>RequireJS语法允许他们尽可能快的被加载，尽管用作顺序，但是也会考虑正顺的依赖顺序，尽管全局变量未被创建，它使得<a href="#multiversion">加载多同一模块的多版本</a>成为可能。</p>

<p>（如果你熟悉或正在使用CommonJS模块，请看下这一节<a href="commonjs.html">CommonJS Notes</a>，关于如何将RequireJS模块格式映射为CommonJS模块。）</p>

<p>There should only be <strong>one</strong> module definition per file on disk. The modules can be grouped into optimized bundles by the <a href="optimization.html">optimization tool</a>.</p>

<div class="subSection">
<h4>
<a name="defsimple">简单 Name/Value 键值对</a>
<span class="sectionMark">&sect; 1.2.1</span>
</h4>

<p>如果模块没有其它任何依赖，并且只是一个name/value的键值对集合，就可以传一个对象到define()中：</p>

<pre><code>//Inside file my/shirt.js:
define({
    color: "black",
    size: "unisize"
});
</code></pre>
</div>

<div class="subSection">
<h4>
<a name="deffunc">定义函数</a>
<span class="sectionMark">&sect; 1.2.2</span>
</h4>

<p>如果模块没有其它依赖，但需要使用一个函数来完成一些初始化工作，然后定义它自已，传一个函数到define()中：</p>

<pre><code>//my/shirt.js now does setup work
//before returning its module definition.
define(function () {
    //Do setup work here

    return {
        color: "black",
        size: "unisize"
    }
});
</code></pre>
</div>

<div class="subSection">
<h4><a name="defdep">定义一个有依赖的函数</a><span class="sectionMark">&sect; 1.2.3</span></h4>

<p>如果该模块有其它依赖，第一个参数应该是一个依赖名称的数组，第二个参数应是一个定义函数。该耿耿数会调用该模块的define一次，当加载完成时。该函数会返回一个对像。。。。依赖会作为函数参数传给定义函数，和依赖数组有着相同的顺序。</p>

<pre><code>//my/shirt.js now has some dependencies, a cart and inventory
//module in the same directory as shirt.js
define(["./cart", "./inventory"], function(cart, inventory) {
        //return an object to define the "my/shirt" module.
        return {
            color: "blue",
            size: "large",
            addToCart: function() {
                inventory.decrement(this);
                cart.add(this);
            }
        }
    }
);
</code></pre>

<p>在这个示例中，一个 my/shirt的模块被创建。它依赖于一个 car和 inventory。在硬盘上，这些文件有着下面的结构：</p>

<ul>
<li>my/cart.js</li>
<li>my/inventory.js</li>
<li>my/shirt.js</li>
</ul>

<p>这个方法调用上面定义的两个参数。 cart 和 inventory。 这两个模块用./ 的模块名。</p>

<p>这个函数直到cart…模块被加载完之后才会被调用，函数接收cart inventory参数作为模块。</p>

<p>模块定义全局是不被推荐的，所以一个模块的多个版本能同时存在一个页面。所以，函数参数和配依赖顺序应一致。</p>

<p>return对应调用shirt 模块定义。通过这种方式的模块定义，shirt不以一种全局对象存在。</p>
</div>

<div class="subSection">
<h4><a name="funcmodule">将模块定义成一个函数</a><span class="sectionMark">&sect; 1.2.4</span></h4>

<p>模块不是必须要有一个return对象。函数中任意有效的返回值都有效。这里有一个模块返回一个函数作为模块定义：</p>

<pre><code>//A module definition inside foo/title.js. It uses
//my/cart and my/inventory modules from before,
//but since foo/bar.js is in a different directory than
//the "my" modules, it uses the "my" in the module dependency
//name to find them. The "my" part of the name can be mapped
//to any directory, but by default, it is assumed to be a
//sibling to the "foo" directory.
define(["my/cart", "my/inventory"],
    function(cart, inventory) {
        //return a function to define "foo/title".
        //It gets or sets the window title.
        return function(title) {
            return title ? (window.title = title) :
                   inventory.storeName + ' ' + cart.name;
        }
    }
);
</code></pre>
</div>

<div class="subSection">
<h4><a name="cjsmodule">以Simplified CommonJS Wrapper的方式定义模块</a><span class="sectionMark">&sect; 1.2.5</span></h4>

<p>如果你想重用之前写过的一些代码<a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS module format</a>，在依赖数组方面将有很大麻烦。所以，Node0.5将支持一个有限的defin()函数支提供Commonjs的简单包装。所以你想构建一个小型的功能块并且你想让它即能工作在node，同时也能在浏览器上跑，你可以使用scw。If you wish to reuse some code that was written in the traditional <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS module format</a> it may be difficult to re-work to the array of dependencies used above. Also, Node 0.5 will likely support a limited kind of define() function that provides a simple wrapper over CommonJS files. So if you are building a small utility and you wish it to be used in both Node (without using the <a href="node.html">RequireJS Node adapter</a>), and in the browser, you can use the <a href="commonjs.html">simplified CommonJS wrapper</a>.</p>

<p>如果你有很多依赖，它会非常有用，保持依赖数据位置同步，如果function参数位置未被指定。</p>

<p>这个包装器依赖于Function.prototype.toString()给出一个有效function内容字符值。这在一些设备如PS3和都的浏览器中不被技持。。其它设备中使用<a href="optimization.html">optimizer</a>去按数组格式去拉依赖。</p>
</div>

<div class="subSection">
<h4><a name="modulename">定义一个有名字的模块</a><span class="sectionMark">&sect; 1.2.6</span></h4>

<p>你或许遇到一些define()中包含一个名字作为模块在第一个define参数中：</p>

<pre><code>    //Explicitly defines the "foo/title" module:
    define("foo/title",
        ["my/cart", "my/inventory"],
        function(cart, inventory) {
            //Define foo/title object in here.
       }
    );
</code></pre>

<p>这是<a href="optimization.html">optimization tool</a>中所生成的。你可以指定模块名，但它使得模块弱。。。如果你移动这个模块从一个目录到另一个目录，你不得不发它的名字。这里最好避免为模块起名，就让op tool生成模块名字好了。op tool需要添加名字从而不只一个模块在一个文件中，让浏览器更快的加载。</p>
</div>

<div class="subSection">

<h4><a name="modulenotes">其它模块备注</a><span class="sectionMark">&sect; 1.2.7</span></h4>

<p id="modulenotes-onemodule"><strong>一个文件一个模块。</strong>：一个JavaScript文件中应只定义一个模块使用最自然的名字和路径的查找约定。多个模块应使用<a href="optimization.html">优化工具</a>来合并到一个文件, 但只能使用优化工具来这样做</p>

<p id="modulenotes-relative"><strong>define()里的依赖模块名称</strong>：为了define()函数内的 require("./relative/name") 调用能够被执行，这里要确保定义"require"作为依赖，这样相关的模块名才能被正确查找：</p>

<pre><code>define(["require", "./relative/name"], function(require) {
    var mod = require("./relative/name");
});
</code></pre>

<p>或者更好的是，这里有一个短语法可被用在<a href="commonjs.html">translating CommonJS</a> 模块中：</p>

<pre><code>define(function(require) {
    var mod = require("./relative/name");
});
</code></pre>

<p>这种格式会使用Function.prototype.toString()去查找require()调用，然后将其和"require"一起加入依赖数组，所以代码使用相对路径也能很好的工作。</p>

<p id="modulenotes-urls"><strong>生成相对于模块的URL路径</strong>：你可能需要生成一个相对于模块的URL路径。没问题，使用"require"作为依赖然后使用require.toUrl()方法来生成该URL：</p>

<pre><code>define(["require"], function(require) {
    var cssUrl = require.toUrl("./style.css");
});
</code></pre>

<p id="modulenotes-console"><strong>在Console中调试</strong>：如果你需要在Console窗口中使用一个已通过 require(["module/name"], function(){})被加载到的模块时，你可以使用require()方式，通过模块的名称来取到它：</p>

<pre><code>require("module/name").callSomeFunction()
</code></pre>

<p>记得这仅在，如果使用相对路径，像'./module/name'，它们仅在define内生效Note this only works if "module/name" was previously loaded via the async version of require: require(["module/name"]). </p>
</div>

<div class="subSection">
<h4><a name="circular">循环依赖</a><span class="sectionMark">&sect; 1.2.8</span></h4>

<p>如果你定义了一个循环依赖（A依赖B然后B回过来依赖A），这种场景下，当B的模块函数被调用，它将得到一个未定义的A。B能取得A晚一会通过使用require()方法（确保指定require作为依赖，正确的上下文被用作于找到A）：</p>

<pre><code>//Inside B.js:
define(["require", "A"],
    function(require, a) {
        //"a" in this case will be null if A also asked for B,
        //a circular dependency.
        return function(title) {
            return require("A").doSomething();
        }
    }
);
</code></pre>

<p>一般情况下，你不需要使用require去获取模块，但是依赖于模块传入一个参数，循环依赖是一个特例，这种情况下require()则可以解决问题。</p>

<p>如果你熟悉CommonJS模块，你可以使用<strong>exports</strong>作为依赖，去为模块创建空对象。在循环依赖两侧都做这些，你可以安全的在其它参数中使用函数参数。</p>
</div>

<h3><a name="i18n">定义一个I18N的包</a><span class="sectionMark">&sect; 1.3</span></h3>

<p>一旦你的Web程序上了规模并且有很多用户，界面中字符的本地化和提供当地特有的一些信息将会变得非常有用。However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</p>

<p>RequireJS允许你先建立一个基本的本地信息模块，而不是强迫你一开始就要打造一个即全又大的本地化信息包。它能随时被不断增加，而且在这些本地化的文件中仅是一些简单的字符串/值的键值对。</p>

<p>i18n包通过i18n.js插件来实现。当一个模块或依赖需要i18n时，它会自动被下载 (下面有更多介绍). <a href="download.html#i18n">下载插件</a> 然后将其放到和你main JS相同的目录下。</p>

<p>定义一个bundle，将其放到名为 "nls"的目录下 -- i18n! 插件假设模块同名js文件位于nls目录下。"n" The "nls" marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). 如果你想要为"my"的模块集提供一组color的名称时，你应创建如下结构的目录：</p>

<ul>
<li>my/nls/colors.js</li>
</ul>

<p>color.js内容如下：</p>

<pre><code>//my/nls/colors.js contents:
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    }
});
</code></pre>

<p>一个有着"root"属性的对象定义了这个模块。这是你必须要为下面的本地化工作要做的全部了.</p>

<p>你可以在其它模块中使用刚才定义的模块了，也就是说，在 my/lamps.js 文件中应这样使用：</p>

<pre><code>//Contents of my/lamps.js
define(["i18n!my/nls/colors"], function(colors) {
    return {
        testMessage: "The name for red in this locale is: " + colors.red
    }
});
</code></pre>

<p>my/lamps模块有一个名为 "testMessage" 的属性使用colors.red用来作color red的本地化显示工作。</p>

<p>以后，如果你想在文件中加入一个新的翻译，例如fr-fr，修发my/nls/colors 文件到如下：</p>

<pre><code>//Contents of my/nls/colors.js
define({
    "root": {
        "red": "red",
        "blue": "blue",
        "green": "green"
    },
    "fr-fr": true
});
</code></pre>

<p>然后新建 my/nls/fr-fr/colors.js 文件并包含下面内容：</p>

<pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "red": "rouge",
    "blue": "bleu",
    "green": "vert"
});
</code></pre>

<p>RequireJS会使用浏览器中的navigator.language或navigator.userLanguage属性来监测相应的local从而查对对应的my/nls/color，也就是说你的应用没必要个性。如果你需要指定locale，使用locale: configuration 参数 (查看<a href="#config">配置参数</a>一节。</p>

<p><strong>注意</strong>RequireJS只会识别小写的locale，为避免大小写问题，所有bundles的目录和文个名都应使用小写。</p>

<p>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is "en-us", then the "root" bundle will be used. If the locale is "fr-fr-paris" then the "fr-fr" bundle will be used.</p>

<p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p>

<pre><code>//Contents of my/nls/fr-fr/colors.js
define({
    "blue": "bleu",
    "green": "vert"
});
</code></pre>

<p>Then the value for red in "root" will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</p>

<ul>
<li>my/nls/fr-fr-paris/colors.js</li>
<li>my/nls/fr-fr/colors.js</li>
<li>my/nls/fr/colors.js</li>
<li>my/nls/colors.js</li>
</ul>

<p>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</p>

<pre><code>//my/nls/colors.js contents:
define({
    "root": true,
    "fr-fr": true,
    "fr-fr-paris": true
});
</code></pre>

<p>and the root bundle would look like:</p>

<pre><code>//Contents of my/nls/root/colors.js
define({
    "red": "red",
    "blue": "blue",
    "green": "green"
});
</code></pre>

<h3><a name="text">使用文本文件作为依赖</a><span class="sectionMark">&sect; 1.4</span></h3>

<p>使用标准的HTML标签构建HTML页面相对于在script中构建DOM结构要舒服的多。但是在JavaScript文件中嵌入HTML却没有什么好办法。目前最好的方法是使用HTML拼接的字符串，但这又很难管理，特别是多行的HTML。</p>

<p>RequireJS有一个text.js的插件，能解决这个问题。如果在依赖中使用test!前缀，该文件会被自动加载。 <a href="download.html#text">下载插件</a>然后放到main JS下同的目录下。</p>

<p>你可以像下面一样指定一个文本文件作为依赖：</p>

<pre><code>require(["some/module", "text!some/module.html", "text!some/module.css"],
    function(module, html, css) {
        //the html variable will be the text
        //of the some/module.html file
        //the css variable will be the text
        //of the some/module.css file.
    }
);
</code></pre>

<p>Notice the .html and .css suffixes to specify the extension of the file. The "some/module" part of the path will be resolved according to normal module name resolution: it will use the <strong>baseUrl</strong> and <strong>paths</strong> <a href="#config">configuration options</a> to map that name to a path.</p>

<p>对于 HTML/XML/SVG 文件，这里有另一种方式。你可以使用!strip 前缀，它能去除XML声明，所以不用担心多余的SVG和XML文档被加到文 档中来。还有，如果这个字符串是一个HTML文档，仅会返回body标签中的部分。如下：</p>

<pre><code>require(["text!some/module.html!strip"],
    function(html) {
        //the html variable will be the text of the
        //some/module.html file, but only the part
        //inside the body tag.
    }
);
</code></pre>

<p>文本文件通过异步XMLHttpRequest (XHR)调用被加载，所以你只能在同一个域中来调用.</p>

<p>However, the build system for RequireJS will inline any text! references with the actual text file contents into the modules, so after a build, the modules that have text! dependencies can be used from other domains.</p>

<h3><a name="jsonp">指定JSONP服务作为依赖</a><span class="sectionMark">&sect; 1.5</span></h3>

<p><a href="http://en.wikipedia.org/wiki/JSON#JSONP">JSONP</a> 是JavaScrit中调用服务的一种方式。它支持跨域并且仅通过script标签中使用HTTP GET请求来调用服务。</p>

<p>在RequireJS使用JSONP，指定"define"作为回调参数的值。 这意味着如果它是一个模块定义，就能过通JSONP的URL值来取值。</p>

<p>这里有一个终端调用JSONP API的示例。在这个示例中，JSONP的回调参数被命名为 "callback"，所以， "callback=define"告诉API将JSON返回值包装在一个"define()" 内：</p>

<pre><code>require(["http://example.com/api/data.json?callback=define"],
    function (data) {
        //The dta object will be the API response for the
        //JSONP data call.
        console.log(data);
    }
);
</code></pre>

<p>JSONP的这种用法将被限制于JSONP服务的应用初始化构建。如果JSONP服务超时，那么其它你通过define()的模块将得不到返回值，错误处理也不可靠。</p>

<p><strong>JSONP返回值必须是JSON对象所支持的</strong>。JSONP如果返回一个数组，字符串或数字将会出错。</p>

<p>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</p>

<p>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override require.onError() to get errors. The error object passed to the onerror function will contain two properties if it is a timeout issue:</p>

<ul>
<li><strong>requireType</strong>: value will be "timeout"</li>
<li><strong>requireModules</strong>: an array of module names/URLs that timed out. You can find the JSONP service URL in here.</li>
</ul>

<p>Note however that if you get this type of error it probably means other modules you defined via define() did not get executed, and the scripts you want to use may not be available.</p>

<h3><a name="order">指定顺序加载脚本</a><span class="sectionMark">&sect; 1.6</span></h3>

<p>Normally RequireJS loads and evaluates scripts in an undetermined order. However, there are some traditional scripts that depend on being loaded in a specific order. For those cases you can use the <strong>order</strong> plugin. <a href="download.html#order">Download the plugin</a> and put it in the same directory as your app's main JS file. Example usage:</p>

<pre><code>require(["order!one.js", "order!two.js", "order!three.js"], function () {
    //This callback is called after the three scripts finish loading.
});
</code></pre>

<p>Scripts loaded by the <strong>order</strong> plugin will be fetched asynchronously, but evaluated in the order they are passed to require, so it should still perform better than using script tags in the head of an HTML document.</p>

<p>The <strong>order</strong> plugin is best used with traditional scripts. It is not needed for scripts that use define() to define modules. It is possible to mix and match "order!" dependencies with regular dependencies, but only the "order!" ones will be evaluated in relative order to each other. </p>

<p><strong>Notes:</strong></p>

<ul>
    <li>The order! plugin only works with JavaScript files that are cacheable by the browser. If the JS file has headers that do not allow the browser to cache the file, then the order of scripts will not be maintained.</li>
    <li>Do not use the order! plugin to load other plugin-loaded resources. For instance. 'order!cs!my/coffescript/module' is not recommended. You will get errors in some versions of IE and WebKit. This is due to the workarounds the order plugin needs to do for those browsers to ensure ordered execution.</li>
</ul>

<h3><a name="pageload">Page Load事件支持/DOM Ready</a><span class="sectionMark">&sect; 1.7</span></h3>

<p>当使用RequireJS载入脚本足够快，很有可能发生在DOM对象加载完成之前。任何操作DOM的方法都应等DOM加载完成之后去执行。对现代浏览器来说，只需要等待DOMContentLoaded的事件就可以了。</p>

<p>但是并非所有的浏览器都支持DOMContentLoaded。domReady模块实现了一个跨浏览器的监测DOM完成的方法。<a href="download.html#domReady">下载模块</a> 在你的项目按如下格式使用：</p>

<pre><code>require(['domReady'], function (domReady) {
  domReady(function () {
    //This function is called once the DOM is ready.
    //It will be safe to query the DOM and manipulate
    //DOM nodes in this function.
  }):
});
</code></pre>

<p>尽管DOM ready是大多数应用所需要的，但像上面示例中API的嵌套函数还应尽量避免。domReady模块同样也实现了<a href="plugin.html">Loader插件API</a>，所以你可以使用loader插件语法(注意domReady依赖中的<b>!</b>) 来强制
require() 回调函数等待DOM完成后再去执行。在loader插件中domReady会返回当前文档：</p>

<pre><code>require(['domReady!'], function (doc) {
    //This function is called once the DOM is ready,
    //notice the value for 'domReady!' is the current
    //document.
  }):
});
</code></pre>

<p><b>Note:</b> If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS "timeout" error. If this a problem either increase the <a href="#config-waitSeconds">waitSeconds</a> configuration, or just use domReady as a module and
call domReady() inside the require() callback.</p>

<p id="domReadyWithResources"><b>DOM Ready with implicit dependencies</b>: If you are working on a project that does not use require() and define() to explicitly indicate dependencies in all scripts, you many notice some errors when waiting for the DOM to be ready then executing code that depends on those implicit dependencies.</p>

<p>The best fix is to wrap all scripts in explicit define() calls that specify all the direct dependencies. However, if that is not an option, you can call a special method on the domReady plugin to wait for all scripts to load and the DOM to be ready:</p>

<pre><code>require(['domReady'], function (domReady) {
  domReady.withResources(function () {
    //This function is called once the DOM is ready,
    //and all modules/plugin resources that RequireJS is loading
    //finish loading.
  }):
});
</code></pre>

<p><b>你应避免使用该函数</b>，在每个文件中使用明确的依赖代替。
但尽管如此，作为一个让项目能使用RequireJS的中间补丁，还是有很用的。</p>

<p></div></p>

<div class="section">
<h2>
<a name="mechanics">Mechanics</a>
<span class="sectionMark">&sect; 2</span>
</h2>

<p>RequireJS使用head.appendChild()将每个依赖看作script标签来加载。</p>

<p>RequireJS等待所有依赖去加载，计算定义模块调用函数的正确顺序，然后按正确的顺序调用模块定义函数。</p>

<p>同步加载使用require.load()在服务器端JavaScript环境中使用RequireJS 将会很容易。这由构建系统来完成，require.load方法在 build/jslib/requirePatch.js 文件里。</p>

<p>将来，这段代码可能会被提交到 require/ 目录作为可选模块，这样，你就能在主机环境中使用正确的行为加载你自己的环境。</p>
</div>

<div class="section">
<h2>
<a name="config">配置参数</a>
<span class="sectionMark">&sect; 3</span>
</h2>

<p>当在HTML页面顶部使用require() (或script文件顶部没有定义模块), 一个配置对象将作为默认配置被传递：</p>

<pre><code>&lt;script type="text/javascript" src="scripts/require.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
  require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15,
    locale: "fr-fr"
  });
  require( ["some/module", "my/module", "a.js", "b.js"],
    function(someModule,    myModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    }
  );
&lt;/script&gt;
</code></pre>

<p>Also, you can define require to be an object <strong>before</strong> require.js is
loaded, and have the values applied.
This example specifies some dependencies to load as soon as require.js defines require():</p>

<pre><code>&lt;script type="text/javascript"&gt;
    var require = {
        deps: ["some/module1", "my/module2", "a.js", "b.js"],
        callback: function(module1, module2) {
            //This function will be called when all the dependencies
            //listed above in deps are loaded. Note that this
            //function could be called before the page is loaded.
            //This callback is optional.
        }
    };
&lt;/script&gt;
&lt;script type="text/javascript" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<p><b>备注：</b> 最好使用<code>var require = {}</code> 并且不要使用
<code>window.require = {}</code>，在IE中会工作不正常。</p>

<p>配置参数：</p>

<p id="config-baseUrl"><strong>baseUrl</strong>: 用作所有模块的查找根目录。在上面的示例中，"my/module"的脚本标签将被转换为 src="/another/path/my/module.js". 当加载plain.js文件时baseUrl是<strong>不</strong>需要的，这些字符串被用脸盘 作为-是，所以a.js和b.js将从相同的目录下被加载。</p>

<p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a <strong>data-main</strong> attribute is used, that path will become the baseUrl.</p>

<p>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</p>

<p id="config-paths"><strong>paths</strong>: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a "/" or has a URL protocol in it ("like http:"). In those cases, the path is determined relative to baseUrl. Using the above sample config, "some/module"'s script tag will be src="/another/path/some/v1.0/module.js". The path that is used for a module name should <strong>not</strong> include the .js extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path.</p>

<p id="config-packagePaths"><strong>packagePaths</strong>: configures module name prefixes to map to CommonJS packages. See the <a href="#packages">packages topic</a> for more information. Related to <strong>packages</strong> config option.</p>

<p id="config-packages"><strong>packages</strong>: configures loading modules from CommonJS packages. See the <a href="#packages">packages topic</a> for more information. Related to <strong>packagePaths</strong> config option.</p>

<p id="config-waitSeconds"><strong>waitSeconds</strong>: The number of seconds to wait before giving up on loading a script. The default is 7 seconds.</p>

<p id="config-locale"><strong>locale</strong>: The locale to use for loading i18n bundles. By default navigator.language or navigator.userLanguage will be used. The proper syntax for specifying a locale is using lowercase and separating values by dashes, for instance: "fr-fr-paris" or "en-us".</p>

<p id="config-context"><strong>context</strong>: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the <a href="#multiversion">Multiversion Support</a> section.</p>

<p id="config-deps"><strong>deps</strong>: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined.</p>

<p id="config-callback"><strong>callback</strong>: A function to pass to require that should be require after <strong>deps</strong> have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's <strong>deps</strong> array has been loaded.</p>

<p id="config-priority"><strong>priority</strong>: An array of module/file names to load immediately, before tracing down any other dependencies. This allows you to set up a small set of files that are downloaded in parallel that contain most of the modules and their dependencies already built in. More information is in the <a href="faq-optimization.html#priority">Optimization FAQ, Priority Downloads</a>.<b>Note:</b> resources loaded by loader plugins (like 'text!template.html') <b>cannot</b> be specified in the priority array: the priority mechanism only works with regular JavaScript resources.</p>

<p id="config-xhtml"><strong>xhtml</strong>: If set to true, document.createElementNS() will be used to create script elements.</p>

<p id="config-urlArgs"><strong>urlArgs</strong>: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</p>

<pre><code>urlArgs: "bust=" +  (new Date()).getTime()
</code></pre>

<p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p>

<p id="config-jQuery"><strong>jQuery</strong>: (RequireJS 0.25.0+) specify an exact version match for the version of jQuery that should be allowed to register as the 'jquery' dependency. This is useful in environments where multiple jQuery files could be loaded but you want
to be sure to get the right version of jQuery for your loading context. Normally you do not need to set this if you are only loading one version of jQuery in a page. However, if you use third party libraries that may also load jQuery, it is best to set this option.</p>

<p id="config-catchError"><strong>catchError</strong>: (RequireJS 0.26.0+) Normally, errors evaluating define() factory functions are not caught, to allow easy debugging during development. However, for some scenarios and production deployments, it is useful to have the errors caught. By specifying catchError.define = true, the errors will be caught and passed to require.onError(). Normally require.onError() throws the error, but you can override the definition of require.onError() to do something different.</p>

</div>

<div class="section">
<h2>
<a name="advanced">高级用法</a>
<span class="sectionMark">&sect; 4</span>
</h2>

<h3><a name="packages">从包中加载模块</a><span class="sectionMark">&sect; 4.1</span></h3>

<p>RequireJS支持从<a href="http://wiki.commonjs.org/wiki/Packages/1.1">CommonJS Packages</a>目录结构中加载模块。但需要做一些额外的配置。. 特别指出，这里支持以下CommonJS Packages特性：</p>

<ul>
<li>A package can be associated with a module name/prefix.</li>
<li>The package config can specify the following properties for a specific package:
<ul>
<li><strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li>
<li><strong>location</strong>: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</li>
<li><strong>main</strong>: The name of the module inside the package that should be used when someone does a require for "packageName". The default value is "main", so only specify it if it differs from the default. The value is relative to the package folder.</li>
</ul></li>
</ul>

<p><strong>重要备注</strong></p>

<ul>
<li>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the <a href="commonjs.html#autoconversion">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li>
<li>The <strong>lib</strong> directory option that may be used in packages is not supported. It causes some confusing path issues.</li>
<li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href="#multiversion">multiversion support</a> to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</li>
</ul>

<p>If you use a similar project layout as specified in the <a href="start.html">Start Guide</a>, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>There are two types of packages you may use in your project -- packages made by other people (third-party packages), and packages that you make as part of your project (source packages). It is suggested that you use two different directories inside scripts to keep track of them. For third-party packages, a <strong>.packages</strong> is recommended, where source packages can just be directories that are siblings to require.js. The third-party packages likely do not need to be committed to your source control, so you can put .packages in your source control's ignore file (.gitignore, .hgignore, etc...).</p>

<p>However, you will want to remember what third-party packages you are using, and where you got them. For that reason, it is suggested that you construct a <strong>package.json</strong> file in the <strong>scripts</strong> directory and use a <a href="http://wiki.commonjs.org/wiki/Packages/Mappings"><strong>mappings</strong></a> section in the package.json file to remember the locations.</p>

<p>Here is how the example directory layout looks with two third-party packages, <strong>alpha</strong> and <strong>omega</strong>, and has two source packages, <strong>cart</strong> and <strong>store</strong>:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>.gitignore (ignores .packages)</li>
<li>.packages/
<ul>
<li>alpha/
<ul>
<li>main.js</li>
</ul></li>
<li>omega/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>main.js</li>
</ul></li>
<li>store/
<ul>
<li>main.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>The <strong>package.json</strong> for the project might be as simple as this, just to track where alpha and omega came from, since they are not committed to source control:</p>

<pre><code>{
    "mappings": {
        "alpha": "http://example.com/packages/alpha/0.4.zip",
        "omega": "http://example.com/pacakges/omega/1.0.zip"
    }
}
</code></pre>

<p><strong>project.html</strong>含有一个下面一行似的script标签：</p>

<pre><code>&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;
</code></pre>

<p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong> uses the <strong>packagePaths</strong> config option to set up the location of the the third party packages, where "packages" is used to set up packages that are relative to require.js, which in this case are the source packages "cart" and "store":</p>

<pre><code>//main.js contents
//Pass a config object to require
require.config({
    packagePaths: {
        ".packages": ["alpha", "omega"]
    },
    "packages": ["cart", "store"]
});

require(["alpha", "omega", "cart", "store", "store/util"],
function (alpha,   omega,   cart,   store,   util) {
    //use the modules as usual.
});
</code></pre>

<p>A require of "alpha" means that it will be loaded from <strong>scripts/.packages/alpha/main.js</strong>, since "main" is the default main module setting supported by RequireJS. A require of "store/util" will be loaded from <strong>scripts/store/util.js</strong>.</p>

<p>If the "alpha" and "store" packages did not follow the "main.js" convention, and looked more like this:</p>

<ul>
<li>project-directory/
<ul>
<li>project.html</li>
<li>scripts/
<ul>
<li>.gitignore (ignores .packages)</li>
<li>.packages/
<ul>
<li>alpha/
<ul>
<li>index.js</li>
</ul></li>
<li>omega/
<ul>
<li>main.js</li>
</ul></li>
</ul></li>
<li>cart/
<ul>
<li>main.js</li>
</ul></li>
<li>store/
<ul>
<li>store.js</li>
<li>util.js</li>
</ul></li>
<li>main.js</li>
<li>package.json</li>
<li>require.js</li>
</ul></li>
</ul></li>
</ul>

<p>Then the RequireJS configuration would look like so:</p>

<pre><code>require.config({
    packagePaths: {
        ".packages": [
            {
                name: "alpha",
                main: "index"
            },
            "omega"
        ]
    },
    "packages": [
        "cart",
        {
            name: "store",
            main: "store"
        }
    ]
});
</code></pre>

<p><strong>packagePaths</strong> is just a convenience for listing several packages that are not direct siblings of require.js, but still have a common directory parent. The above configuration could be written like so with just the <strong>packages</strong> config option, by using the <strong>location</strong> property for each third-party package:</p>

<pre><code>require.config({
    "packages": [
        {
            name: "alpha",
            location: ".packages/alpha",
            main: "index"
        },
        {
            name: "omega",
            location: ".packages/omega"
        }
        "cart",
        {
            name: "store",
            main: "store"
        }
    ]
});
</code></pre>

<p>为了避免冗余，这里强烈推荐使用。。。。, it is strongly suggested to always use packages that use "main" convention in their structure, and use packagePaths for third party packages.</p>

<p>To make fetching and configuring packages easier, there are designs for a command line package tool in the works.</p>

<h3><a name="multiversion">多版本支持</a><span class="sectionMark">&sect; 4.2</span></h3>

<p>正如在<a href="#config">配置参数</a>一节所提到，模块的多版本能通过不同的“上下文”配置参数在同一页面中被加载。 require.config() 返回一个require函数将使用上下文配置。这里有一个示例去加载两个不同版本的模块：alpha和beta（示例来自于其中的一个测试文件）：</p>

<pre><code>&lt;script type="text/javascript" src="../require.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});

reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
             omega.version); //prints 1
      }
    );
  }, 100);
});

var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });

reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
&lt;/script&gt;
</code></pre>

<p>Note that "require" is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If "require" is not specified as a dependency, then there will likely be an error.</p>

<h3><a name="afterload">Page Load结束后加载代码</a><span class="sectionMark">&sect; 4.3</span></h3>

<p>在<strong>Multiversion Support</strong>一节的代码示例中显示了如何通过嵌套require()调用让代码晚加载。</p>

<h3><a name="webworker">Web Worker支持</a><span class="sectionMark">&sect; 4.4</span></h3>

<p>在0.12版本后，RequireJS就能在Web Worker中来运行。通过使用importScripts()来加载require.js (或者JS文 件中包含require()定义），然后进行require调用。</p>

<p>你能可需要查看<strong>baseUrl</strong>的<a href="#config">参数配置</a> 来确保require() 能加载到相应的script文件。</p>

<p>你可以查下下面一个在单元测试中用来查找文件的示例：<a href="http://github.com/jrburke/requirejs/blob/master/tests/workers.js"></a>.</p>

<h3><a name="rhino">Rhino支持</a><span class="sectionMark">&sect; 4.5</span></h3>

<p>RequireJS可以通过<a href="download.html#rjs">r.js adapter</a>来支持Rhino。查看<a href="https://github.com/jrburke/r.js/blob/master/README.html">the r.js README</a>获得更多信息。</p>
</div>
    </div>
    <div id="footer" class="mono">
        <span class="line">Latest Release: <a href="/docs/download.html">1.0.3</a></span>
        <span class="line">Open source: <a href="https://github.com/jrburke/requirejs/blob/master/LICENSE">new BSD or MIT licensed</a></span>
        <span class="line">web design by <a href="http://andychung.ca">Andy Chung</a> &copy; 2011</span>
        <span class="line">中文翻译<a href="http://lanvige.com">ET Team</a> &copy; 2012</span>
    </div>
</div>

</body>
</html>
