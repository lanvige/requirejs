<!DOCTYPE html>
<html>
<head>
    <title>为什么需要AMD？</title>

    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    
    <link rel="stylesheet" type="text/css" href="../main.css">
    <link rel="icon" type="image/x-icon" href="/favicon.png">
    <!--[if IE]> <link rel="stylesheet" type="text/css" href="../ie.css" /> <![endif]-->
    <link rel="stylesheet" type="text/css" href="http://ajax.usesos.com/ajax/libs/dojo/1.4/dojox/highlight/resources/highlight.css">

    <script type="text/javascript" src="http://ajax.usesos.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
    <script type="text/javascript" src="../init.js"></script>
    <script src="http://ajax.usesos.com/ajax/libs/dojo/1.4/dojo/dojo.xd.js"></script>
    <script type="text/javascript">
        dojo.require("dojox.highlight");
        dojo.require("dojox.highlight.languages.javascript");
        dojo.require("dojox.highlight.languages.html");
        dojo.ready(function() {
            dojo.query("pre > code")
                .forEach(function(node) {
                    if (node.innerHTML.indexOf("DOCTYPE") !== -1 || node.innerHTML.indexOf('&lt;script') !== -1) {
                        dojo.addClass(node, "html");
                    } else {
                        dojo.addClass(node, "javascript");
                    }
                })
                .forEach(dojox.highlight.init);
        });
    </script>
</head>
<body>
<div id="grid"></div>
<div id="wrapper">

    <div id="navBg"></div>
    <div id="nav" class="mono">
        <a class="homeImageLink" href="../"></a>
        <h1>a javascript module loader</h1>

        <ul>
            <li class="hbox">
                <a href="../">主页</a>
                <span class="spacer boxFlex"></span>
                <span class="icon home"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="start.html">开始</a>
                <span class="spacer boxFlex"></span>
                <span class="icon start"></span>
            </li>
            <li class="hbox">
                <a class="local" href="download.html">下载</a>
                <span class="spacer boxFlex"></span>
                <span class="icon download"></span>
            </li>
            <li class="hbox">
                <a class="local" href="api.html">API</a>
                <span class="spacer boxFlex"></span>
                <span class="icon api"></span>
            </li>
            <li class="hbox">
                <a class="local" href="optimization.html">优化</a>
                <span class="spacer boxFlex"></span>
                <span class="icon optimize"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="jquery.html">结合jQuery一起使用</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="node.html">结合Node一起使用</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="dojo.html">结合Dojo一起使用</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
            <li class="hbox">
                <a class="local" href="commonjs.html">CommonJS备注</a>
                <span class="spacer boxFlex"></span>
                <span class="icon script"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="faq.html">FAQs</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="errors.html">常见错误</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="plugins.html">写一个插件</a>
                <span class="spacer boxFlex"></span>
                <span class="icon api"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a class="local" href="why.html">为什么需要Web模块化</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="whyamd.html">为什么需要AMD</a>
                <span class="spacer boxFlex"></span>
                <span class="icon question"></span>
            </li>
            <li class="hbox">
                <a class="local" href="requirements.html">需求</a>
                <span class="spacer boxFlex"></span>
                <span class="icon requirement"></span>
            </li>
            <li class="hbox">
                <a class="local" href="history.html">历史版本</a>
                <span class="spacer boxFlex"></span>
                <span class="icon history"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a href="http://groups.google.com/group/requirejs">需要帮助</a>
                <span class="spacer boxFlex"></span>
                <span class="icon help"></span>
            </li>
            <li class="hbox">
                <a href="http://tagneto.blogspot.com">作者博客</a>
                <span class="spacer boxFlex"></span>
                <span class="icon blog"></span>
            </li>
            <li class="hbox">
                <a href="http://twitter.com/jrburke">Twitter</a>
                <span class="spacer boxFlex"></span>
                <span class="icon twitter"></span>
            </li>
        </ul>

        <ul>
            <li class="hbox">
                <a href="http://github.com/jrburke/requirejs">GitHub</a>
                <span class="spacer boxFlex"></span>
                <span class="icon git"></span>
            </li>
            <li class="hbox">
                <a class="local" href="contributing.html">贡献</a>
                <span class="spacer boxFlex"></span>
                <span class="icon fork"></span>
            </li>
            <li class="hbox">
                <a class="local" href="translate.html">中文翻译</a>
                <span class="spacer boxFlex"></span>
                <span class="icon fork"></span>
            </li>
        </ul>

        <ul>
            <li class="version">1.0.3 文档</li>
        </ul>
    </div>

    <div id="content"><div id="directory" class="section">
<h1>为什么需要AMD？</h1>

<ul class="index mono">
    <li class="hbox">
        <a href="#purposes">模块化的目的</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1</span>
    </li>
    <li class="hbox">
        <a href="#today">Web的现状</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span>
    </li>
    <li class="hbox">
        <a href="#commonjs">CommonJS</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span>
    </li>
    <li class="hbox">
        <a href="#amd">AMD</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4</span>
    </li>
    <li class="hbox">
        <a href="#definition">模块定义</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5</span>
    </li>
    <li class="hbox">
        <a href="#namedmodules">模块命名</a><span class="spacer boxFlex"></span><span class="sect">&sect; 6</span>
    </li>
    <li class="hbox">
        <a href="#sugar">语法糖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 7</span>
    </li>
    <li class="hbox">
        <a href="#commonjscompat">与CommonJS兼容</a><span class="spacer boxFlex"></span><span class="sect">&sect; 8</span>
    </li>
    <li class="hbox">
        <a href="#amdtoday">AMD使用现况</a><span class="spacer boxFlex"></span><span class="sect">&sect; 9</span>
    </li>
    <li class="hbox">
        <a href="#youcando">你能做什么</a><span class="spacer boxFlex"></span><span class="sect">&sect; 10</span>
    </li>
</ul>

<p>这篇文中讨化有关这种设计影响和使用<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">异步模块定义AMD API</a>作为Javascript模块化，RequireJS中支持模块API, 这里还有另一篇文章关于 <a href="why.html">Web上的模块化通用方案</a>的文章。</p>

</div>

<div class="section">
<h2>
<a name="purposes">模块化的目的</a>
<span class="sectionMark">&sect; 1</span>
</h2>

<p>什么是JavaScript模块？是用来干什么的？</p>

<ul>
<li><strong>定义</strong>：如何压缩一段代码到一个可用的单元，并且如何为模块注册功能/导出一个值。</li>
<li><strong>依赖引用</strong>：如何引用到其它的代码单元。</li>
</ul>

</div>

<div class="section">
<h2>
<a name="today">Web的现状</a>
<span class="sectionMark">&sect; 2</span>
</h2>

<pre><code>(function () {
    var $ = this.jQuery;

    this.myExample = function () {};
}());
</code></pre>

<p>现在的JavaScript代码块是如何被定义的？</p>

<ul>
    <li>通过立即执行的factory函数。</li>
    <li>通过在HTML script标签中定义全局变量名，引用到依赖都完成。</li>
    <li>？？依赖都非常的弱：开发者需要知道正确的依赖关系。举例来说，Backbone依赖于jQuery，所以jQuery引用标签必须放在Backbone之前。</li>
    <li>为了优化性能，在部署时需要第三方工具来将一组script标签合并成一个。</li>
</ul>

<p>这对于一个大型项目来非常难以管理，特别是当依赖开始重复和嵌套时。手写script标签很不灵活，？并且还没有将脚本的按需加载给考虑进来。</p>

</div>

<div class="section">
<h2>
<a name="commonjs">CommonJS</a>
<span class="sectionMark">&sect; 3</span>
</h2>

<pre><code>var $ = require('jquery');
exports.myExample = function () {};
</code></pre>

<p>最初的<a href="http://groups.google.com/group/commonjs">CommonJS (CJS) list</a> 决定为现在的JavaScript语言制定一个模块的格式，但是不仅限于浏览器端的JS环境。这个权宜之计包括： </p>

<ul>
<li>无论是使用一个服务器去转换CJS模块使其在浏览器中也能有用武之地。</li>
<li>或者使用XMLHttpRequest(XHR)去加载文本模块然后在浏览器中做文本的转义和解析。</li>
</ul>

<p>CJS模块格式仅允许一个文件包括一个模块，所以一个“传输格式”将被使用成不止一个模块为性能和。。用途。</p>

<p>为了这个目的，CommonJS组开始致力于解决依赖引用和如何处理循环引用的问题，并且如何为当前模块获取更多属性。无论如何，它们没有完全解决一点在浏览器环境下的问题，而这些问题一直影响着模块的设计：</p>

<ul>
<li>网络加载</li>
<li>天然异步</li>
</ul>

<p>这意味着他们让放任前端开发人员支实现自己的格式，并且这种方案让调试变得更加麻烦。？？调试多个文件合并成一个文件有难度。这些难题也许有一天会被写入浏览器工具，但最终的结论是：使用CommonJS 模块在大多数的JS环境，也就是浏览器中，还不适合。</p>

</div>

<div class="section">
<h2>
<a name="amd">AMD</a>
<span class="sectionMark">&sect; 4</span>
</h2>

<pre><code>define(['jquery'] , function ($) {
    return function () {};
});
</code></pre>

<p>AMD格式来自于想要一个模块格式优于当今的“写一长串的script标签，还不得不自己操心那些引用次序”一些东西在浏览器中很方便直接使用，一些好的调试不需要。。。。这来自于Dojo's现实世界体验，使用XHR+eval。。。</p>

<p>这相对于Web现行的全局和脚本标答来说是一种提高，因为：</p>

<ul>
<li>使用CommonJS使用ID作为依赖解决方案。清除依赖声明并避免使用全局。</li>
<li>ID映射到其它路径上。这允许替换实现。这将为单元测试创建modks提供巨大的方便。对上面的代码示例来说，这段代码仅实现了jQuery ApI和行为，不一定要用有jQuery。</li>
<li>包装模块定义。提供工具从而避免对全局空间进行污染。</li>
<li>清除path支定义模块值。无论使用"return value;" 或者是CommonJS的 "exports"哲学，都将对循环引用有很大的帮助。</li>
</ul>

<p>这对于CommonJS模块来说是一种改进：</p>

<ul>
<li>在浏览器上工作的更好，它有着最少的了解。其它方式在调试、跨域及CDN等方面都有问题，如果想使用file://则需要特别的服务器端工具。</li>
<li>定义一种一个文件中含多个模块的用法。在CommonJS规定中，这种规定叫名“传输格式”（"transport format"），但CommonJS组还不允许这种格式。</li>
<li>允许设置一个功能作为返回值。这对构造函数非常有用。在CommonJS中不大好，总是不得不支设置属性在Export对象上。 Node支持module.exports = function() {}，但这不属于CommonJS规范中的一部分。</li>
</ul>

</div>

<div class="section">
<h2>
<a name="definition">模块定义</a>
<span class="sectionMark">&sect; 5</span>
</h2>

<p>AMD的基本核心，功能，作为单元的包装已经被理解了，也被文当化在模块模式中, 函数，作为一个代码单元已经能被很好的理解。在<a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">module pattern</a>有更多描述：</p>

<pre><code>(function () {
   this.myGlobal = function () {};
}());
</code></pre>

<p>这种类型的模块依赖于附加属性到全局对象上从而导出模块钱，然后这样很难声明模块的依赖。假设将代码被执行时依赖能立即使用。这限制了依赖的加载策略。</p>

<p>AMD通过以下方式解决这些问题：</p>

<ul>
<li>通过调用define()来注册factory方法，而不是直接调用它。</li>
<li>Pass依赖一个字符串型的数组，不去做全局污染。</li>
<li>当所有的依赖都被加载和执行后，公有factory方法被执行。</li>
<li>将依赖的模块作为参数传递给factory方法。</li>
</ul>

<pre><code>//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
});
</code></pre>

</div>

<div class="section">
<h2>
<a name="namedmodules">Named Modules</a>
<span class="sectionMark">&sect; 6</span>
</h2>

<p>上面的示例在文件仅包含一个定义call 时工作的很好， AMD加载器有足够的信息（模块名称/ID）支加载脚本。无论如何，为了最好的性能，你还是要将一些模块文件合并在一起。所以，为了允许这些，define()允许传充一个字符串作为第一参数去指定字符串名称：</p>

<pre><code>//Calling define with module ID, dependency array, and factory function
define('myModule', ['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
}});
</code></pre>

<p>如果你仅在一个文件中定义一个模块，则可以很灵活的使用匿名模块。这样可以很方便的移动文件，或者改文件名。</p>

<p>无论如何，对于一些现在Web上常用的JavaScript库，定义一个匿名模块是很危险的，因为它们可能会被加载到页面上，而不是使用AMD加载器。如果发生了这种情况，AMD加载器就没有足够的信息去给这个模块命名。jQuery和undersocre就属于这种类型。</p>

<p>使用这些Web端流行的JS库，使用命名的define() 调用是最好的避免错误的方式，当网页上使用大量的第三方脚本。</p>

</div>

<div class="section">
<h2>
<a name="sugar">Sugar</a>
<span class="sectionMark">&sect; 7</span>
</h2>

<p>上面的AMD示例在所有的浏览器中都能正常工作，但是，这里有一个风险，如果你的模块名和后面的命名function参数不匹配，并且可能看起来有点奇怪，如果这个模块有太多依赖的话：</p>

<pre><code>define([ "require", "jquery", "blade/object", "blade/fn", "rdapi",
         "oauth", "blade/jig", "blade/url", "dispatch", "accounts",
         "storage", "services", "widgets/AccountPanel", "widgets/TabButton",
         "widgets/AddAccount", "less", "osTheme", "jquery-ui-1.8.7.min",
         "jquery.textOverflow"],
function (require,   $,        object,         fn,         rdapi,
          oauth,   jig,         url,         dispatch,   accounts,
          storage,   services,   AccountPanel,           TabButton,
          AddAccount,           less,   osTheme) {

});
</code></pre>

<p>让这些变得简单些，让我们在CommonJS模块上做一个“简单的包装”使它变得更加简单，这种定式表单现在也被技持了。</p>

<pre><code>define(function (require) {
    var dependency1 = require('dependency1'),
        dependency2 = require('dependency2');

    return function () {};
});
</code></pre>

<p>AMD加载器将使用Fuction.prototype.toString()来对require('')调用进行转换，然后在内部将上面的defaine call转为下面：</p>

<pre><code>define(['require', 'dependency1', 'dependency2'], function (require) {
    var dependency1 = require('dependency1'),
        dependency2 = require('dependency2');

    return function () {};
});
</code></pre>

<p>这将允许加载器支加载dependency1,2异步，执行这些依赖，然后执行function方法。</p>

<p>并非所有的浏览器使用一个可用的Function.prototype.toString()结果。就像在2011年10月，ps3和老的Opera移动浏览器就不。这些浏览器更需要一个为网络、设备优化的构建工具，所以又做了一个。。。的工具，就像。。。<a href="optimization.html">RequireJS optimizer</a>.</p>

<p>不支持toString()扫描的浏览器还是很少的，所以放心的用sugared吧。</p>

</div>

<div class="section">
<h2>
<a name="commonjscompat">CommonJS Compatibility</a>
<span class="sectionMark">&sect; 8</span>
</h2>

<p>尽管这种语法糖格式参考"SCW"，它不是绝对的兼容CommonJs 模块。无论如何，这种案例不支持，尽管它们常用假设异步依赖加载。</p>

<p>大多数的CommonJS模块，据多经验95%，都适全simplified wrapping。</p>

<p>模块打破一个做动态依赖计算，都不用一个字符串作为require()调用， 并且没有任何：</p>

<pre><code>//BAD
var mod = require(someCondition ? 'a' : 'b');

//BAD
if (someCondition) {
    var a = require('a');
} else {
    var a = require('a1');
}
</code></pre>

<p>这种例子由<a href="https://github.com/amdjs/amdjs-api/wiki/require">callback-require</a>来处理，<code>require([moduleName], function (){})</code>只是来做正常的加载。</p>

<p>AMD 执行model更适合。CommonJS模块不支持AMD wrapper同时也不支持和谐模块。AMD的代码执行方式与未来更加容。</p>

<h2>冗余度和可用性</h2>

<p>对AMD提出的第一个批评是，最少相对于CJS模块来说，就是它需要一组缩进和要用一个函数来包装一下。</p>

<p>这是一个不争的事实：这个额外的函数的多一级的缩进对于AMD的使用来说不是什么问题。 当你编程时，你的主要时间是花在：</p>

<ul>
<li>思考问题。</li>
<li>阅读代码。</li>
</ul>

<p>你编程时大多数的时间是花在思考上，而不是输入。虽然代码更少让人觉得很爽，但这种方式要付出一种代价？，更何况使用AMD时需要的额外的代码并不多。</p>

<p>大多数的Web开发者都会使用一个包装函数去避免页面的全局污染。找一个写好的包装函数来看一下，你会发现这种作法很常见，而且不会对模块的阅读带来任何负担。</p>

<p>使用CommonJS格式还会有以下的潜在成本：</p>

<ul>
    <li>使用这些依赖工具的成本</li>
    <li>一些特殊情况会使浏览器崩溃，像跨域访问</li>
    <li>很差的调试支持，这会持续增加你的使用成本</li>
</ul>

<p>AMD模块不需要太多的工具，只有少数的边界问题和更好的调试支持。</p>

<p>什么是最重要的: 能真正的重用代码。AMD则能以最小的花费来实现这一目的。</p>

<p>还在做另一件事，做一个最好的JavaScript模块化系统，使得在现代浏览器中调试有着很好的真实体验。
</p>

<p>AMD还有其相关的APIs，来帮助构建未来JS模块系统：</p>

<ul>
<li><strong>返回一个函数来作为模块值</strong>, 就像一个构造函数，带来更好的API设计。Node有 module.exports来做这件事，但使用"return function (){}"会显得代码更加的整洁。这意味着不必为了得到一个"module"的句柄而去做module.exports，同时语义也更加的清晰。</li>
<li><strong>动态代码加载</strong> (在AMD系统中通过<a href="https://github.com/amdjs/amdjs-api/wiki/require">require([], function (){}))</a>来完成是一个基本需求。在CJS中也有过讨论，有过一些建议，但完全不被接受。Node也不为此提供任何支持，反而依赖于require('')的同步行为，这对Web来说很不灵活。</li>
<li><strong><a href="http://requirejs.org/docs/plugins.html">插件加载器</a></strong>非常有用。它帮助在回调式编程中避免. It helps avoid the nested brace indenting common in callback-based programming.</li>
<li><strong>可以选择映射一个模块</strong>去加载另一个地址从而很方便的为测试创建模拟对象。</li>
<li>There should only be at most <strong>对于每个模块的IO操作</strong>，而且它应该是简单的。浏览器不能容忍为了找一个模块进行多次的IO操作。这个假设违反了Node的多次路径查找，为了避免使用package.json "main"属性。就用模块名称以项目路径来查找其它模块，一个好的约定可以减少很多冗余的配置，但也提供了一个简单的配置，如果真的需要。</li>
<li>最好有一个<strong>"opt-in" call</strong>，这样老的JavaScript代码在新的系统里也能很好的工作。</li>
</ul>

<p>如果一个JavaScript模块系统不能提供上述功能，那对比AMD和其相关API<a href="https://github.com/amdjs/amdjs-api/wiki/require">callback-require</a>，<a href="https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins">加载插件</a>，和基于路径的模块ID</p>则有着重大不足。

</div>

<div class="section">
<h2>
<a name="amdtoday">AMD使用现况</a>
<span class="sectionMark">&sect; 9</span>
</h2>

<p>在2011年10月中旬，AMD在Web上已经有了不错的表现：</p>

<ul>
<li><a href="http://jquery.com/">jQuery</a> 1.7</li>
<li><a href="http://dojotoolkit.org/">Dojo</a> 1.7</li>
<li><a href="http://mootools.net/">MooTools</a> 2.0</li>
<li><a href="http://uxebu.github.com/embedjs/">EmbedJS</a></li>
<li><a href="http://ender.no.de/">Ender</a>-associated modules like <a href="https://github.com/ded/bonzo">bonzo</a>, <a href="https://github.com/ded/qwery">qwery</a>, <a href="https://github.com/fat/bean">bean</a> and <a href="https://github.com/ded/domready">domready</a></li>
<li>Used by <a href="http://getfirebug.com/">Firebug</a> 1.8+</li>
<li>Simplified CommonJS wrapper能被用在<a href="https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/">Jetpack/Add-on SDK</a> for Firefox</li>
<li>被部分使用在了<a href="http://www.bbc.co.uk/">the BBC</a> (仅用来查找资源，不是AMD/RequireJS官方最推荐的部分</li>
</ul>

</div>

<div class="section">
<h2>
<a name="youcando">你能做什么</a>
<span class="sectionMark">&sect; 10</span>
</h2>

<p id="doapp"><strong>如果你要写一个应用程序：</strong></p>

<ul>
<li>如果想体验下AMD加载器，你有以下几个选择：
<ul>
<li><a href="http://requirejs.org">RequireJS</a></li>
<li><a href="https://github.com/unscriptable/curl">curl</a></li>
<li><a href="https://github.com/zazl/lsjs">lsjs</a></li>
<li><a href="http://dojotoolkit.org/">Dojo</a> 1.7 and <a href="http://mootools.net/">MooTools</a> 2.0 each have their own</li>
</ul></li>
<li>如果你想使用AMD，但页面中还是使用<strong>尾部写script标签加载</strong>的方式：
<ul>
<li>Use the <a href="http://requirejs.org/docs/optimization.html">RequireJS optimizer</a> either in command line mode or as an <a href="https://github.com/jrburke/r.js/blob/master/build/tests/http/httpBuild.js">HTTP service</a> with the <a href="https://github.com/jrburke/almond">almond AMD shim</a>.</li>
</ul></li>
</ul>

<p id="dolib"><strong>如果你是一个脚本/库的作者</strong>:</p>

<ul>
<li><a href="https://gist.github.com/1262861">选择性调用define()</a>如果这个可行。好消息就是你的代码就可以不用依赖于AMD了，这将允许你模块的使用者：
<ul>
<li>避免在页面中大量使用全局变量</li>
<li>为代码加载、延迟加载提供更多选项</li>
<li>使用现有的AMD工具来优化他们的项目</li>
<li>为现在浏览器端的JS提供一个可行的模块系统</li>
</ul></li>
</ul>

<p id="doenv"><strong>如果你为JavaScript写代码加载器/引擎/环境：</strong></p>

<ul>
<li>实现<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD API</a>。这里有一份<a href="https://groups.google.com/group/amd-implement">讨论列表</a>和<a href="https://github.com/amdjs/amdjs-tests">兼容性测试</a>。通过实现AMD，你将减少多模块系统间的引用，打造一个可行的Web JavaScript模块系统。这将反馈给ECMAScript去打造更好的原生的模块支持。</li>
<li>同时也支持<a href="https://github.com/amdjs/amdjs-api/wiki/require">callback-require</a>和<a href="https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins">插件加载</a>. 插件加载看起来和callback/async-style代码没什么区别，但却是减少嵌套调用很好的方式。</li>
</ul>

</div>
    </div>
    <div id="footer" class="mono">
        <span class="line">Latest Release: <a href="/docs/download.html">1.0.3</a></span>
        <span class="line">Open source: <a href="https://github.com/jrburke/requirejs/blob/master/LICENSE">new BSD or MIT licensed</a></span>
        <span class="line">web design by <a href="http://andychung.ca">Andy Chung</a> &copy; 2011</span>
        <span class="line">中文翻译<a href="http://lanvige.com">ET Team</a> &copy; 2012</span>
    </div>
</div>

</body>
</html>
