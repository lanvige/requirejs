<div id="directory" class="section">
<h1>为什么需要AMD？</h1>

<ul class="index mono">
    <li class="hbox">
        <a href="#purposes">模块化的目的</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1</span>
    </li>
    <li class="hbox">
        <a href="#today">Web的现状</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span>
    </li>
    <li class="hbox">
        <a href="#commonjs">CommonJS</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span>
    </li>
    <li class="hbox">
        <a href="#amd">AMD</a><span class="spacer boxFlex"></span><span class="sect">&sect; 4</span>
    </li>
    <li class="hbox">
        <a href="#definition">模块定义</a><span class="spacer boxFlex"></span><span class="sect">&sect; 5</span>
    </li>
    <li class="hbox">
        <a href="#namedmodules">模块命名</a><span class="spacer boxFlex"></span><span class="sect">&sect; 6</span>
    </li>
    <li class="hbox">
        <a href="#sugar">语法糖</a><span class="spacer boxFlex"></span><span class="sect">&sect; 7</span>
    </li>
    <li class="hbox">
        <a href="#commonjscompat">与CommonJS兼容</a><span class="spacer boxFlex"></span><span class="sect">&sect; 8</span>
    </li>
    <li class="hbox">
        <a href="#amdtoday">AMD使用现况</a><span class="spacer boxFlex"></span><span class="sect">&sect; 9</span>
    </li>
    <li class="hbox">
        <a href="#youcando">你能做什么</a><span class="spacer boxFlex"></span><span class="sect">&sect; 10</span>
    </li>
</ul>

<p>这篇文中讨化有关这种设计影响和使用<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">异步模块定义AMD API</a>作为Javascript模块化，RequireJS中支持模块API, 这里还有另一篇文章关于 <a href="why.html">Web上的模块化通用方案</a>的文章。</p>

</div>


<div class="section">
<h2>
<a name="purposes">模块化的目的</a>
<span class="sectionMark">&sect; 1</span>
</h2>

<p>什么是JavaScript模块？是用来干什么的？</p>

<ul>
<li><strong>定义</strong>：如何压缩一段代码到一个可用的单元，并且如何为模块注册功能/导出一个值。</li>
<li><strong>依赖引用</strong>：如何引用到其它的代码单元。</li>
</ul>

</div>


<div class="section">
<h2>
<a name="today">Web的现状</a>
<span class="sectionMark">&sect; 2</span>
</h2>

<pre><code>(function () {
    var $ = this.jQuery;

    this.myExample = function () {};
}());
</code></pre>

<p>现在的JavaScript代码块是如何被定义的？</p>

<ul>
    <li>通过立即执行的factory函数。</li>
    <li>通过在HTML script标签中定义全局变量名，引用到依赖都完成。</li>
    <li>？？依赖都非常的弱：开发者需要知道正确的依赖关系。举例来说，Backbone依赖于jQuery，所以jQuery引用标签必须放在Backbone之前。</li>
    <li>为了优化性能，在部署时需要第三方工具来将一组script标签合并成一个。</li>
</ul>

<p>这对于一个大型项目来非常难以管理，特别是当依赖开始重复和嵌套时。手写script标签很不灵活，？并且还没有将脚本的按需加载给考虑进来。</p>

</div>

<div class="section">
<h2>
<a name="commonjs">CommonJS</a>
<span class="sectionMark">&sect; 3</span>
</h2>

<pre><code>var $ = require('jquery');
exports.myExample = function () {};
</code></pre>

<p>最初的The original <a href="http://groups.google.com/group/commonjs">CommonJS (CJS) list</a> 决定为现在的JavaScript语言制定一个模块的格式，但是不仅限于浏览器端的JS环境。这个权宜之计包括： </p>

<ul>
<li>Either use a server to translate CJS modules to something usable in the browser.</li>
<li>Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.</li>
</ul>

<p>CJS模块格式仅允许一个文件包括一个模块，所以一个“传输格式”将被使用成不止一个模块为性能和。。用途。</p>

<p>为了这个目的，CommonJS组开始致力于解决依赖引用和如何处理循环引用的问题，并且如何为当前模块获取更多属性。无论如何，它们没有完全解决一点在浏览器环境下的问题，而这些问题一直影响着模块的设计：</p>

<ul>
<li>网络加载 </li>
<li>inherent asynchronicity</li>
</ul>

<p>这意味着他们让放任前端开发人员支实现自己的格式，并且这种方案让调试变得更加麻烦。？？调试多个文件合并成一个文件有难度。这些难题也许有一天会被写入浏览器工具，但最终的结论是：使用CommonJS 模块在大多数的JS环境，也就是浏览器中，还不适合。</p>

</div>

<div class="section">
<h2>
<a name="amd">AMD</a>
<span class="sectionMark">&sect; 4</span>
</h2>

<pre><code>define(['jquery'] , function ($) {
    return function () {};
});
</code></pre>

<p>AMD格式来自于想要一个模块格式优于当今的“写一长串的script标签，还不得不自己操心那些引用次序”一些东西在浏览器中很方便直接使用，一些好的调试不需要。。。。这来自于Dojo's现实世界体验，使用XHR+eval。。。</p>

<p>这相对于Web现行的全局和脚本标答来说是一种提高，因为：</p>

<ul>
<li>使用CommonJS使用ID作为依赖解决方案。清除依赖声明并避免使用全局。</li>
<li>ID映射到其它路径上。这允许替换实现。这将为单元测试创建modks提供巨大的方便。对上面的代码示例来说，这段代码仅实现了jQuery ApI和行为，不一定要用有jQuery。</li>
<li>包装模块定义。提供工具从而避免对全局空间进行污染。</li>
<li>清除path支定义模块值。无论使用"return value;" 或者是CommonJS的 "exports"哲学，都将对循环引用有很大的帮助。</li>
</ul>

<p>这对CommonJS模块来说是一种改进：</p>

<ul>
<li>在浏览器上工作的更好， it has the least amount of gotchas. Other approaches have problems with debugging, cross-domain/CDN usage, file:// usage and the need for server-specific tooling.</li>
<li>Defines a way to include multiple modules in one file. In CommonJS terms, the term for this is a "transport format", and that group has not agreed on a transport format.</li>
<li>允许设置一个功能作为返回值。这对构造函数非常有用。在CommonJS中不大好，总是不得不支设置属性在Export对象上。 Node支持module.exports = function() {}，但这不属于CommonJS spec中的一部分。</li>
</ul>

</div>

<div class="section">
<h2>
<a name="definition">Module Definition</a>
<span class="sectionMark">&sect; 5</span>
</h2>

<p>AMD的基本核心，功能，作为单元的包装已经被理解了，也被文当化在module pattern:中, the function, is already well understood as a unit of encapsulation. It has also been documented as the <a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">module pattern</a>:</p>

<pre><code>(function () {
   this.myGlobal = function () {};
}());
</code></pre>

<p>That type of module relies on attaching properties to the global object to export the module value, and it is difficult to declare dependencies with this model. The dependencies are assumed to be immediately available when this function executes. This limits the loading strategies for the dependencies.</p>

<p>AMD addresses these issues by:</p>

<ul>
<li>通过调用define()来注册factory方法，而不是直接调用它。</li>
<li>Pass依赖一个字符串型的数组，不去做全局污染。</li>
<li>当所有的依赖都被加载和执行后，公有factory方法被执行。</li>
<li>将依赖的模块作为参数传递给factory方法。</li>
</ul>

<pre><code>//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
});
</code></pre>

</div>

<div class="section">
<h2>
<a name="namedmodules">Named Modules</a>
<span class="sectionMark">&sect; 6</span>
</h2>

<p>上面的示例在文件仅包含一个定义call 时工作的很好， AMD加载器有足够的信息（模块名称/ID）支加载脚本。无论如何，为了最好的性能，你还是要将一些模块文件合并在一起。所以，为了允许这些，define()允许传充一个字符串作为第一参数去指定字符串名称：</p>

<pre><code>//Calling define with module ID, dependency array, and factory function
define('myModule', ['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
}});
</code></pre>

<p>如果你仅在一个文件中定义一个模块，则可以很灵活的使用匿名模块。这样可以很方便的移动文件，或者改文件名。</p>

<p>However, for some popular JS libraries in use on the web now, defining an anonymous module might be hazardous since they could be loaded on a page, without using an AMD loader. If there happens to be an AMD loader on the page, the AMD loader will not have enough information to give the module a name. jQuery and underscore are examples of scripts that fall in this category.</p>

<p>使用这些Web端流行的JS库，使用命名的define() 调用是最好的避免错误的方式，当网页上使用大量的第三方脚本。</p>

</div>

<div class="section">
<h2>
<a name="sugar">Sugar</a>
<span class="sectionMark">&sect; 7</span>
</h2>

<p>上面的AMD示例在所有的浏览器中都能正常工作，但是，这里有一个风险，如果你的模块名和后面的命名function参数不匹配，并且可能看起来有点奇怪，如果这个模块有太多依赖的话：</p>

<pre><code>define([ "require", "jquery", "blade/object", "blade/fn", "rdapi",
         "oauth", "blade/jig", "blade/url", "dispatch", "accounts",
         "storage", "services", "widgets/AccountPanel", "widgets/TabButton",
         "widgets/AddAccount", "less", "osTheme", "jquery-ui-1.8.7.min",
         "jquery.textOverflow"],
function (require,   $,        object,         fn,         rdapi,
          oauth,   jig,         url,         dispatch,   accounts,
          storage,   services,   AccountPanel,           TabButton,
          AddAccount,           less,   osTheme) {

});
</code></pre>

<p>让这些变得简单些，让我们在CommonJS模块上做一个“简单的包装”使它变得更加简单，这种定式表单现在也被技持了。</p>

<pre><code>define(function (require) {
    var dependency1 = require('dependency1'),
        dependency2 = require('dependency2');

    return function () {};
});
</code></pre>

<p>AMD加载器将使用Fuction.prototype.toString()来对require('')调用进行转换，然后在内部将上面的defaine call转为下面：</p>

<pre><code>define(['require', 'dependency1', 'dependency2'], function (require) {
    var dependency1 = require('dependency1'),
        dependency2 = require('dependency2');

    return function () {};
});
</code></pre>

<p>这将允许加载器支加载dependency1,2异步，执行这些依赖，然后执行function方法。</p>

<p>并非所有的浏览器使用一个可用的Function.prototype.toString()结果。就像在2011年10月，ps3和老的Opera移动浏览器就不。这些浏览器更需要一个为网络、设备优化的构建工具，所以又做了一个。。。的工具，就像。。。<a href="optimization.html">RequireJS optimizer</a>.</p>

<p>不支持toString()扫描的浏览器还是很少的，所以放心的用sugared吧。</p>

</div>

<div class="section">
<h2>
<a name="commonjscompat">CommonJS Compatibility</a>
<span class="sectionMark">&sect; 8</span>
</h2>

<p>尽管这种语法糖格式参考"SCW"，它不是绝对的兼容CommonJs 模块。无论如何，这种案例不支持，尽管它们常用假设异步依赖加载。</p>

<p>大多数的CommonJS模块，据多经验95%，都适全simplified wrapping。</p>

<p>模块打破一个做动态依赖计算，都不用一个字符串作为require()调用， 并且没有任何：</p>

<pre><code>//BAD
var mod = require(someCondition ? 'a' : 'b');

//BAD
if (someCondition) {
    var a = require('a');
} else {
    var a = require('a1');
}
</code></pre>

<p>这种例子由<a href="https://github.com/amdjs/amdjs-api/wiki/require">callback-require</a>来处理，<code>require([moduleName], function (){})</code>只是来做正常的加载。</p>

<p>AMD 执行model更适合。CommonJS模块不支持AMD wrapper同时也不支持和谐模块。AMD的代码执行方式与未来更加容。</p>

<h2>Verbosity vs. Usefulness</h2>

<p>One of the criticisms of AMD, at least compared to CJS modules, is that it requires a level of indent and a function wrapping.</p>

<p>But here is the plain truth: the perceived extra typing and a level of indent to use AMD does not matter. Here is where your time goes when coding:</p>

<ul>
<li>Thinking about the problem.</li>
<li>Reading code.</li>
</ul>

<p>Your time coding is mostly spent thinking, not typing. While fewer words are generally preferable, there is a limit to that approach paying off, and the extra typing in AMD is not that much more.</p>

<p>Most web developers are use a function wrapper anyway, to avoid polluting the page with globals. Seeing a function wrapped around functionality is a very common sight and does not add to the reading cost of a module.</p>

<p>There are also hidden costs with the CommonJS format:</p>

<ul>
    <li>the tooling dependency cost</li>
    <li>edge cases that break in browsers, like cross domain access</li>
    <li>worse debugging, a cost that continues to add up over time</li>
</ul>

<p>AMD modules require less tooling, there are fewer edge case issues, and better debugging support.</p>

<p>What is important: being able to actually share code with others. AMD is the lowest energy pathway to that goal.</p>

<p>Having a working, easy to debug module system that works in today's browsers means getting real world experience in making the best module system for JavaScript in the future.</p>

<p>AMD and its related APIs, have helped show the following for any future JS module system:</p>

<ul>
<li><strong>Returning a function as the module value</strong>, particularly a constructor function, leads to better API design. Node has module.exports to allow this, but being able to use "return function (){}" is much cleaner. It means not having to get a handle on "module" to do module.exports, and it is a clearer code expression.</li>
<li><strong>Dynamic code loading</strong> (done in AMD systems via <a href="https://github.com/amdjs/amdjs-api/wiki/require">require([], function (){}))</a> is a basic requirement. CJS talked about it, had some proposals, but it was not fully embraced. Node does not have any support for this need, instead relying on the synchronous behavior of require(''), which is not portable to the web.</li>
<li><strong><a href="http://requirejs.org/docs/plugins.html">Loader plugins</a></strong> are incredibly useful. It helps avoid the nested brace indenting common in callback-based programming.</li>
<li><strong>Selectively mapping one module</strong> to load from another location makes it easy to provide mock objects for testing.</li>
<li>There should only be at most <strong>one IO action for each module</strong>, and it should be straightforward. Web browsers are not tolerant of multiple IO lookups to find a module. This argues against the multiple path lookups that Node does now, and avoiding the use of a package.json "main" property. Just use module names that map easily to one location based on the project's location, using a reasonable default convention that does not require verbose configuration, but allow for simple configuration when needed.</li>
<li>It is best if there is an <strong>"opt-in" call</strong> that can be done so that older JS code can partcipate in the new system.</li>
</ul>

<p>If a JS module system cannot deliver on the above features, it is at a significant disadvantage when compared to AMD and its related APIs around <a href="https://github.com/amdjs/amdjs-api/wiki/require">callback-require</a>, <a href="https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins">loader plugins</a>, and paths-based module IDs.</p>

</div>

<div class="section">
<h2>
<a name="amdtoday">AMD Used Today</a>
<span class="sectionMark">&sect; 9</span>
</h2>

<p>As of mid October 2011, AMD already has good adoption on the web:</p>

<ul>
<li><a href="http://jquery.com/">jQuery</a> 1.7</li>
<li><a href="http://dojotoolkit.org/">Dojo</a> 1.7</li>
<li><a href="http://mootools.net/">MooTools</a> 2.0</li>
<li><a href="http://uxebu.github.com/embedjs/">EmbedJS</a></li>
<li><a href="http://ender.no.de/">Ender</a>-associated modules like <a href="https://github.com/ded/bonzo">bonzo</a>, <a href="https://github.com/ded/qwery">qwery</a>, <a href="https://github.com/fat/bean">bean</a> and <a href="https://github.com/ded/domready">domready</a></li>
<li>Used by <a href="http://getfirebug.com/">Firebug</a> 1.8+</li>
<li>The simplified CommonJS wrapper can be used in <a href="https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/">Jetpack/Add-on SDK</a> for Firefox</li>
<li>Used for parts of sites on <a href="http://www.bbc.co.uk/">the BBC</a> (observed by looking at the source, not an official recommendation of AMD/RequireJS)</li>
</ul>

</div>

<div class="section">
<h2>
<a name="youcando">你能做什么</a>
<span class="sectionMark">&sect; 10</span>
</h2>

<p id="doapp"><strong>如果你要写一个应用程序：</strong></p>

<ul>
<li>Give an AMD loader a try. You have some choices:
<ul>
<li><a href="http://requirejs.org">RequireJS</a></li>
<li><a href="https://github.com/unscriptable/curl">curl</a></li>
<li><a href="https://github.com/zazl/lsjs">lsjs</a></li>
<li><a href="http://dojotoolkit.org/">Dojo</a> 1.7 and <a href="http://mootools.net/">MooTools</a> 2.0 each have their own</li>
</ul></li>
<li>If you want to use AMD but still use the <strong>load one script at the bottom of the HTML page</strong> approach:
<ul>
<li>Use the <a href="http://requirejs.org/docs/optimization.html">RequireJS optimizer</a> either in command line mode or as an <a href="https://github.com/jrburke/r.js/blob/master/build/tests/http/httpBuild.js">HTTP service</a> with the <a href="https://github.com/jrburke/almond">almond AMD shim</a>.</li>
</ul></li>
</ul>

<p id="dolib"><strong>If you are a script/library author</strong>:</p>

<ul>
<li><a href="https://gist.github.com/1262861">Optionally call define()</a> if it is available. The nice thing is you can still code your library without relying on AMD, just participate if it is available. This allows consumers of your modules to:
<ul>
<li>避免在页面中大量使用全局变量</li>
<li>use more options for code loading, delayed loading</li>
<li>use existing AMD tooling to optimize their project</li>
<li>participate in a workable module system for JS in the browser today.</li>
</ul></li>
</ul>

<p id="doenv"><strong>If you write code loaders/engines/environments for JavaScript:</strong></p>

<ul>
<li>实现<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD API</a>。这里有一份<a href="https://groups.google.com/group/amd-implement">讨论列表</a>和<a href="https://github.com/amdjs/amdjs-tests">兼容性测试</a>。 By implementing AMD, you will reduce multi-module system boilerplate and help prove out a workable JavaScript module system on the web. This can be fed back into the ECMAScript process to build better native module support.</li>
<li>同时也支持<a href="https://github.com/amdjs/amdjs-api/wiki/require">callback-require</a> and <a href="https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins">loader plugins</a>. 插件加载是一个很Loader plugins are a great way to reduce the nested callback syndrome that can be common in callback/async-style code.</li>
</ul>

</div>
