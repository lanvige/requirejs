<div id="directory" class="section">
<h1>在Node中使用RequireJS</h1>

    <ul class="index mono">
        <li class="hbox">
            <a href="#1">Node不是已经有了自己的模块加载器了吗?</a><span class="spacer boxFlex"></span><span class="sect">&sect; 1</span>
        </li>
        <li class="hbox">
            <a href="#2">我可以使用CommonJS的格式来写服务器端模块吗?</a><span class="spacer boxFlex"></span><span class="sect">&sect; 2</span>
        </li>
        <li class="hbox">
            <a href="#3">我该怎样使用?</a><span class="spacer boxFlex"></span><span class="sect">&sect; 3</span>
        </li>
    </ul>

</div>

<div class="section">
<h2>
<a name="1">Node不是已经有了自己的模块加载器了吗?</a>
<span class="sectionMark">&sect; 1</span>
</h2>

<p>是的， <a href="http://nodejs.org">Node</a> 有. 那个加载器使用CommonJS的模块格式。CommonJS 的模块格式是 <a href="why.html">对于浏览器端是不合适的</a>, 但我不同意 <a href="http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html">
一些CommonJS模块格式中所作出的权衡。
</a>. 
通过在服务端使用RequireJS,你可以在客户端和服务端使用相同的模块格式。那样的话，你就可以在浏览器端快速的开发并且易于调试，而不用担心要花费为外的时间来处理两种不同格式的代码。 </p>

<p>在Node 0.5.0 和之后的版本情况有所改变, 他将会支持 <a href="commonjs.html#manualconversion">"simplified CommonJS wrapper" 版本的 define()</a>. 
这对于一些基本的基于CommonJS的库非常有用,但它不包含对<a href="api.html#defdep">define()中依赖数组的支持</a> 和 <a href="plugins.html">RequireJS中的相关插件支持</a>.所以使用RequireJS的r.js适配器将会确保你的代码正确的运行于浏览器和Node环境中.</p>

</div>

<div class="section">
<h2>
<a name="2">我可以使用已经用CommonJS的格式写好的NODE模块吗?</a>
<span class="sectionMark">&sect; 2</span></h2>

<p>是的，RequireJS有一个Node的适配器，名叫r.js, 他会使用Node实现的require和搜索路径来查找那些RequireJS配置文件中没有配置的模块，所以你无需任何改动就可以使用基于Node的模块。</p>

<p>RequireJS 首先会使用它的 <a href="api.html#config">配置选项</a> 来查找模块. 如果RequireJS没有找到对应的模块，那么他会假设使用Node类型的模块和配置。
If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like <a href="http://npmjs.org/">npm</a>, and do not configure their locations with RequireJS.</p>

<p><strong>Best practice</strong>: Use npm to install Node-only packages/modules into the projects <strong>node_modules</strong> directory, but do not configure RequireJS to look inside the node_modules directory. Also avoid using relative module IDs to reference modules that are Node-only modules. So, <strong>do not</strong> do something like <strong>require("./node_modules/foo/foo")</strong>.</p>

<p>Even though RequireJS is an asynchronous loader in the browser, the RequireJS Node adapter loads modules synchronously in the Node environment to match the default loading behavior in Node.</p>

<p>Finally, RequireJS in Node can only load modules that are on the local disk -- fetching modules across http, for instance, is not supported at this time.</p>

</div>

<div class="section">
<h2>
<a name="3">How do I use it?</a>
<span class="sectionMark">&sect; 3</span>
</h2>

<p>There are two ways to get the Node adapter:</p>

<h3 id="npm">npm</h3>
<p>Use <a href="http://npmjs.org">npm</a> to install it:</p>

<pre><code>npm install requirejs
</code></pre>

<p>This option will install the latest release.</p>

<h3 id="rjs">Download r.js</h3>

<p>If you prefer to not use npm, you can get r.js directly:</p>

<ul>
    <li>Download r.js from the <a href="download.html#rjs">the download page</a> and place it in your project.</li>
    <li>Get the source from the <a href="https://github.com/jrburke/r.js">r.js repo</a> and either generate the r.js via "node dist.js", or grab a snapshot from the <strong>dist</strong> directory.</li>
</ul>

<h3 id="usage">Usage<h3>

<p>These instructions assume an npm installation of 'requirejs'. If you are using the r.js file directly, replace  require('requirejs') with require('./path/to/r.js'). Basic usage is:</p>

<ul>
    <li>require('requirejs')</li>
    <li>Pass the main js file's "require" function in the configuration to requirejs.</li>
</ul>

<p>Example:</p>

<pre><code>var requirejs = require('requirejs');

requirejs.config({
    //Pass the top-level main.js/index.js require
    //function to requirejs so that node modules
    //are loaded relative to the top-level JS file.
    nodeRequire: require
});

requirejs(['foo', 'bar'],
function   (foo,   bar) {
    //foo and bar are loaded according to requirejs
    //config, but if not found, then node's require
    //is used to load the module.
});
</code></pre>

<p>Be sure to read the <a href="#2">notes in section 2</a> about configuring RequireJS so that it can load node-only modules installed via npm.</p>

<p>To see a more complete example that loads a module via RequireJS but uses Node-native modules for other things, see the <a href="https://github.com/jrburke/r.js/tree/master/tests/node/embedded">embedded test</a> in the r.js repo.</p>

<h3 id="nodeModules">Building node modules with AMD or RequireJS</h3>

<p>If you want to code a module so that it works with RequireJS and in Node, without requiring users of your library in Node to use RequireJS, then you can use the <a href="https://github.com/jrburke/amdefine">amdefine</a> package to do this:</p>

<pre><code>if (typeof define !== 'function') {
    var define = (require('amdefine'))(module);
}

define(function(require) {
    var dep = require('dependency');

    //The value returned from the function is
    //used as the module export visible to Node.
    return function () {};
});
</code></pre>

<p>The RequireJS optimizer, as of version 1.0.3, will strip out the use of 'amdefine' above, so it is safe to use this module for your web-based projects too. Just be sure to use <strong>the exact 'amdefine' if() test and contents as shown above</strong>. Differences in spaces/line breaks are allowed. See the <a href="https://github.com/jrburke/amdefine">amdefine project</a> for more information.</p>

<p>If you want to use RequireJS directly to code your module, and then export a module value to node so that it can be used in other Node programs without requiring that app to use RequireJS, you can use the code mentioned above in the <a href="#usage">basic usage section</a> with a few modifications.</p>

<p>It is best to set the baseUrl specifically to the directory containing the module, so that it works properly when nested inside a node_modules heirarchy. Then use Node's module.exports to export your module value:</p>

<pre><code>var requirejs = require('requirejs');

requirejs.config({
    //Use node's special variable __dirname to
    //get the directory containing this file.
    //Useful if building a library that will
    //be used in node but does not require the
    //use of node outside
    baseUrl: __dirname,

    //Pass the top-level main.js/index.js require
    //function to requirejs so that node modules
    //are loaded relative to the top-level JS file.
    nodeRequire: require
});

requirejs(['foo', 'bar'],
function   (foo,   bar) {
    //foo and bar are loaded according to requirejs
    //config, but if not found, then node's require
    //is used to load the module.

    //Now export a value visible to Node.
    module.exports = function () {};
});
</code></pre>

<h3 id="optimizer">Using the optimizer as a node module</h3>

<p>The node module also exposes the RequireJS Optimizer as an <strong>optimize</strong> method for using the <a href="optimization.html">RequireJS optimizer</a> via a function call instead of a command line tool:</p>

<pre><code>var requirejs = require('requirejs');

var config = {
    baseUrl: '../appDir/scripts',
    name: 'main',
    out: '../build/main-built.js'
};

requirejs.optimize(config, function (buildResponse) {
    //buildResponse is just a text output of the modules
    //included. Load the built file for the contents.
    //Use config.out to get the optimized file contents.
    var contents = fs.readFileSync(config.out, 'utf8');
});
</code></pre>

<p>This allows you to build other optimization workflows, like <a href="https://github.com/jrburke/r.js/tree/master/build/tests/http">a web builder</a> that can be used if you prefer to always develop with the "one script file included before the &lt;/body&gt; tag" approach. The optimizer running in Node if fairly fast, but for larger projects that do not want to regenerate the build for every browser request, but just if you modify a script that is part of the build. You could use Node's fs.watchFile() to watch files and then trigger the build when a file changes.</p>

<h3 id="feedback">Feedback</h3>

<p>If you find you have a problem, and want to report it, use the <a href="http://github.com/jrburke/r.js/issues">r.js GitHub Issues page</a>.</p>

<p>If you want to discuss the RequireJS-Node integration, you can use the <a href="http://groups.google.com/group/requirejs">RequireJS Group</a>.</p>
</div>
